using Meadow.Core.Cryptography;
using Meadow.Core.RlpEncoding;
using Meadow.Core.Utils;
using Meadow.EVM.Data_Types.Addressing;
using Meadow.EVM.Data_Types.Transactions;
using Meadow.EVM.EVM.Definitions;
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Text;

namespace Meadow.EVM.Data_Types.Block
{
    public class BlockHeader : IRLPSerializable
    {
        #region Properties
        /// <summary>
        /// The hash of the previous block in the chain, also known as the parent block.
        /// </summary>
        public byte[] PreviousHash { get; private set; }
        /// <summary>
        /// A Keccak256 hash of all RLP encoded uncle block headers in this block.
        /// </summary>
        public byte[] UnclesHash { get; private set; }
        /// <summary>
        /// The address which the used gas will be given to and dispensed from afterwards to others.
        /// </summary>
        public Address Coinbase { get; private set; }
        /// <summary>
        /// The State's root hash/key used to access the State Trie.
        /// </summary>
        public byte[] StateRootHash { get; set; }
        /// <summary>
        /// The Transactions root hash/key used to access the Transaction Trie.
        /// </summary>
        public byte[] TransactionsRootHash { get; set; }
        /// <summary>
        /// The Receipts root hash/key used to access the Receipts Trie.
        /// </summary>
        public byte[] ReceiptsRootHash { get; set; }
        /// <summary>
        /// A bloom filter which is used to check inclusiveness of indexable information generated by processing the block (logs/receipts).
        /// </summary>
        public BigInteger Bloom { get; set; }
        /// <summary>
        /// The mining difficulty for this block.
        /// </summary>
        public BigInteger Difficulty { get; set; }
        /// <summary>
        /// The number of the block, of all the blocks in the chain.
        /// </summary>
        public BigInteger BlockNumber { get; private set; }
        /// <summary>
        /// The block's gas limit which it cannot exceed when executing transactions.
        /// </summary>
        public BigInteger GasLimit { get; private set; }
        /// <summary>
        /// The total amount of gas used when executing all the transactions in the block.
        /// </summary>
        public BigInteger GasUsed { get; set; }
        /// <summary>
        /// UNIX timestamp, in seconds from the epoch.
        /// </summary>
        public BigInteger Timestamp { get; private set; }
        /// <summary>
        /// Extra data which can be included with the block. Up to 1024 bytes.
        /// </summary>
        public byte[] ExtraData { get; private set; }
        /// <summary>
        /// A 32-byte Hashimoto digest for the given block header.
        /// </summary>
        public byte[] MixHash { get; set; }
        /// <summary>
        /// Nonce which is used as the proof-of-work for the block (mining works because it is not included with the resulting hashes and needs to be found for the reward). 64-bits in size.
        /// </summary>
        public byte[] Nonce { get; set; }
        #endregion

        #region Constructor
        public BlockHeader() { }
        public BlockHeader(byte[] previousHash, byte[] unclesHash, Address coinbase, byte[] stateRootHash, byte[] transactionRootHash, byte[] receiptsRootHash, BigInteger bloom, BigInteger difficulty, BigInteger blockNumber, BigInteger gasLimit, BigInteger gasUsed, BigInteger timestamp, byte[] extraData, byte[] mixhash, byte[] nonce)
        {
            // Set all of our properties
            PreviousHash = previousHash;
            UnclesHash = unclesHash;
            Coinbase = coinbase;
            StateRootHash = stateRootHash;
            TransactionsRootHash = transactionRootHash;
            ReceiptsRootHash = receiptsRootHash;
            Bloom = bloom;
            Difficulty = difficulty;
            BlockNumber = blockNumber;
            GasLimit = gasLimit;
            GasUsed = gasUsed;
            Timestamp = timestamp;
            ExtraData = extraData;
            MixHash = mixhash;
            Nonce = nonce;
        }

        public BlockHeader(RLPItem rlpBlockHeader)
        {
            Deserialize(rlpBlockHeader);
        }
        #endregion

        #region Functions
        public byte[] GetHash()
        {
            return KeccakHash.ComputeHashBytes(RLP.Encode(Serialize()));
        }

        public byte[] GetMiningHash()
        {
            return KeccakHash.ComputeHashBytes(RLP.Encode(Serialize(ExtraData, null, null)));
        }

        public byte[] GetSigningHash()
        {
            return KeccakHash.ComputeHashBytes(RLP.Encode(Serialize(null, MixHash, Nonce)));
        }

        public void UpdateUnclesHash(BlockHeader[] uncles)
        {
            // We create an RLP list with all of our uncle block headers
            RLPList rlpUncles = new RLPList();
            foreach (BlockHeader uncleHeader in uncles)
            {
                rlpUncles.Items.Add(uncleHeader.Serialize());
            }

            // RLP encode our uncles and hash them
            UnclesHash = KeccakHash.ComputeHashBytes(RLP.Encode(rlpUncles));
        }
        #endregion

        #region Operators
        public static bool operator ==(BlockHeader emp1, BlockHeader emp2)
        {
            if (object.ReferenceEquals(emp1, null) != object.ReferenceEquals(emp2, null))
            {
                return false;
            }

            if (object.ReferenceEquals(emp1, null) && object.ReferenceEquals(emp2, null))
            {
                return true;
            }

            return emp1.GetHash().ValuesEqual(emp2.GetHash());
        }

        public static bool operator !=(BlockHeader emp1, BlockHeader emp2)
        {
            if (object.ReferenceEquals(emp1, null) != object.ReferenceEquals(emp2, null))
            {
                return true;
            }

            if (object.ReferenceEquals(emp1, null) && object.ReferenceEquals(emp2, null))
            {
                return false;
            }

            return !emp1.GetHash().ValuesEqual(emp2.GetHash());
        }

        public override bool Equals(object obj)
        {
            if (!(obj is BlockHeader))
            {
                return false;
            }

            return this == (BlockHeader)obj;
        }

        public override int GetHashCode()
        {
            // Obtain our hash
            byte[] hash = GetHash().Slice(0, 4);

            // If we're in big endian, flip the data
            if (!BitConverter.IsLittleEndian)
            {
                Array.Reverse(hash);
            }

            // Return the first 32-bit integer
            return BitConverter.ToInt32(hash, 0);
        }
        #endregion

        #region RLP Serialization
        /// <summary>
        /// Serializes the block header into an RLP item for encoding.
        /// </summary>
        /// <returns>Returns a serialized RLP block header.</returns>
        public RLPItem Serialize()
        {
            return Serialize(ExtraData, MixHash, Nonce);
        }

        /// <summary>
        /// Serializes the block header into an RLP item for encoding.
        /// </summary>
        /// <returns>Returns a serialized RLP block header.</returns>
        private RLPItem Serialize(byte[] extraData, byte[] mixHash, byte[] nonce)
        {
            // We create a new RLP list that constitute this header.
            RLPList rlpBlockHeader = new RLPList();

            rlpBlockHeader.Items.Add(PreviousHash);
            rlpBlockHeader.Items.Add(UnclesHash);
            rlpBlockHeader.Items.Add(RLP.FromInteger(Coinbase, Address.ADDRESS_SIZE));
            rlpBlockHeader.Items.Add(StateRootHash);
            rlpBlockHeader.Items.Add(TransactionsRootHash);
            rlpBlockHeader.Items.Add(ReceiptsRootHash);
            rlpBlockHeader.Items.Add(RLP.FromInteger(Bloom, EVMDefinitions.BLOOM_FILTER_SIZE));
            rlpBlockHeader.Items.Add(RLP.FromInteger(Difficulty, EVMDefinitions.WORD_SIZE, true));
            rlpBlockHeader.Items.Add(RLP.FromInteger(BlockNumber, EVMDefinitions.WORD_SIZE, true));
            rlpBlockHeader.Items.Add(RLP.FromInteger(GasLimit, EVMDefinitions.WORD_SIZE, true));
            rlpBlockHeader.Items.Add(RLP.FromInteger(GasUsed, EVMDefinitions.WORD_SIZE, true));
            rlpBlockHeader.Items.Add(RLP.FromInteger(Timestamp, EVMDefinitions.WORD_SIZE, true));
            if (extraData != null)
            {
                rlpBlockHeader.Items.Add(extraData);
            }

            if (mixHash != null)
            {
                rlpBlockHeader.Items.Add(mixHash);
            }

            if (nonce != null)
            {
                rlpBlockHeader.Items.Add(nonce);
            }

            // Return our rlp header item.
            return rlpBlockHeader;
        }

        /// <summary>
        /// Deserializes the given RLP serialized block header and sets all values accordingly.
        /// </summary>
        /// <param name="item">The RLP item to block header and obtain values from.</param>
        public void Deserialize(RLPItem item)
        {
            // Verify this is a list
            if (!item.IsList)
            {
                throw new ArgumentException();
            }

            // Verify it has 15 items.
            RLPList rlpBlockHeader = (RLPList)item;
            if (rlpBlockHeader.Items.Count != 15)
            {
                throw new ArgumentException();
            }

            // Verify the types of all items
            for (int i = 0; i < rlpBlockHeader.Items.Count; i++)
            {
                if (!rlpBlockHeader.Items[i].IsByteArray)
                {
                    throw new ArgumentException();
                }
            }

            // Verify our items are the correct length
            if (((RLPByteArray)rlpBlockHeader.Items[0]).Data.Length != KeccakHash.HASH_SIZE)
            {
                throw new ArgumentException();
            }

            if (((RLPByteArray)rlpBlockHeader.Items[1]).Data.Length != KeccakHash.HASH_SIZE)
            {
                throw new ArgumentException();
            }

            if (((RLPByteArray)rlpBlockHeader.Items[2]).Data.Length != Address.ADDRESS_SIZE)
            {
                throw new ArgumentException();
            }

            if (((RLPByteArray)rlpBlockHeader.Items[3]).Data.Length != KeccakHash.HASH_SIZE)
            {
                throw new ArgumentException();
            }

            if (((RLPByteArray)rlpBlockHeader.Items[4]).Data.Length != KeccakHash.HASH_SIZE)
            {
                throw new ArgumentException();
            }

            if (((RLPByteArray)rlpBlockHeader.Items[5]).Data.Length != KeccakHash.HASH_SIZE)
            {
                throw new ArgumentException();
            }

            if (((RLPByteArray)rlpBlockHeader.Items[6]).Data.Length != EVMDefinitions.BLOOM_FILTER_SIZE)
            {
                throw new ArgumentException();
            }


            // Obtain our items
            PreviousHash = rlpBlockHeader.Items[0];
            UnclesHash = rlpBlockHeader.Items[1];
            Coinbase = RLP.ToInteger((RLPByteArray)rlpBlockHeader.Items[2], Address.ADDRESS_SIZE);
            StateRootHash = rlpBlockHeader.Items[3];
            TransactionsRootHash = rlpBlockHeader.Items[4];
            ReceiptsRootHash = rlpBlockHeader.Items[5];
            Bloom = RLP.ToInteger((RLPByteArray)rlpBlockHeader.Items[6], EVMDefinitions.BLOOM_FILTER_SIZE);
            Difficulty = RLP.ToInteger((RLPByteArray)rlpBlockHeader.Items[7]);
            BlockNumber = RLP.ToInteger((RLPByteArray)rlpBlockHeader.Items[8]);
            GasLimit = RLP.ToInteger((RLPByteArray)rlpBlockHeader.Items[9]);
            GasUsed = RLP.ToInteger((RLPByteArray)rlpBlockHeader.Items[10]);
            Timestamp = RLP.ToInteger((RLPByteArray)rlpBlockHeader.Items[11]);
            ExtraData = rlpBlockHeader.Items[12];
            MixHash = rlpBlockHeader.Items[13];
            Nonce = rlpBlockHeader.Items[14]; 
        }
        #endregion
    }
}
