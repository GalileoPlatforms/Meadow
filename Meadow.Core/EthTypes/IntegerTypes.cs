using Meadow.Core.Utils;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Text;

namespace Meadow.Core.EthTypes
{

    #region Base Interface
    public interface IIntegerBase
    {
        #region Properties
        bool Signed { get; }
        int Size { get; }
        #endregion

        #region Functions
        byte[] ToArray(bool littleEndian);
        Span<byte> ToSpan(bool littleEndian);
        BigInteger ToBigInteger();
        string ToHexString(bool hexPrefix);
        #endregion
    }
    #endregion

    #region Signed Types
    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int24 : IIntegerBase, IComparable, IComparable<Int24>, IEquatable<Int24>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 3;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int24 MaxValue = new Int24(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int24 MinValue = new Int24(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int24 Zero = new Int24(0);
        public static readonly Int24 One = new Int24(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int24(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int24(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int24 left, Int24 right) => !(left == right);
        public static bool operator ==(Int24 left, Int24 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int24 left, Int24 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int24 left, Int24 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int24 left, Int24 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int24 left, Int24 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int24 operator %(Int24 dividend, Int24 divisor) => new Int24(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int24 operator +(Int24 left, Int24 right) => new Int24(left.ToBigInteger() + right.ToBigInteger());
        public static Int24 operator -(Int24 left, Int24 right) => new Int24(left.ToBigInteger() - right.ToBigInteger());
        public static Int24 operator *(Int24 left, Int24 right) => new Int24(left.ToBigInteger() * right.ToBigInteger());
        public static Int24 operator /(Int24 dividend, Int24 divisor) => new Int24(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int24 operator >>(Int24 value, int shift) => new Int24(value.ToBigInteger() >> shift);
        public static Int24 operator <<(Int24 value, int shift) => new Int24(value.ToBigInteger() << shift);
        public static Int24 operator |(Int24 left, Int24 right) => new Int24(left.ToBigInteger() | right.ToBigInteger());
        public static Int24 operator &(Int24 left, Int24 right) => new Int24(left.ToBigInteger() & right.ToBigInteger());
        public static Int24 operator ^(Int24 left, Int24 right) => new Int24(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int24 operator ++(Int24 value) => value + One;
        public static Int24 operator --(Int24 value) => value - One;
        public static Int24 operator ~(Int24 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int24(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int24 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int24 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int24 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int24 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static implicit operator int(Int24 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int24 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static implicit operator long(Int24 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int24 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int24 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int24 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int24 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int24 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int24(sbyte value) => new Int24(value);
        public static implicit operator Int24(byte value) => new Int24(value);
        public static implicit operator Int24(short value) => new Int24(value);
        public static implicit operator Int24(ushort value) => new Int24(value);
        public static implicit operator Int24(int value) => new Int24(value);
        public static explicit operator Int24(uint value) => new Int24(value);
        public static explicit operator Int24(long value) => new Int24(value);
        public static explicit operator Int24(ulong value) => new Int24(value);
        public static explicit operator Int24(float value) => FromFloatingType(value);
        public static explicit operator Int24(double value) => FromFloatingType(value);
        public static explicit operator Int24(decimal value) => FromDecimalType(value);
        public static explicit operator Int24(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int24(BigInteger value) => new Int24(value);

        // Sibling Types -> This Type
        public static explicit operator Int24(Int40 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int48 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int56 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int72 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int80 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int88 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int96 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int104 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int112 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int120 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int128 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int136 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int144 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int152 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int160 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int168 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int176 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int184 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int192 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int200 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int208 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int216 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int224 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int232 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int240 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(Int248 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt24 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt40 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt48 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt56 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt72 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt80 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt88 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt96 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt104 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt112 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt120 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt128 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt136 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt144 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt152 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt160 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt168 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt176 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt184 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt192 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt200 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt208 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt216 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt224 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt232 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt240 value) => new Int24(value.ToBigInteger());
        public static explicit operator Int24(UInt248 value) => new Int24(value.ToBigInteger());

        public static Int24 DivRem(Int24 dividend, Int24 divisor, out Int24 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int24(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int24(remainderBigInt);
            return result;
        }

        public static Int24 Pow(Int24 value, int exponent) => new Int24(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int24 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int24 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int24)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int24)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int24)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int24)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int24)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int24)})");
            }

            return new Int24(bigInt);
        }

        static Int24 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int24)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int24)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int24)})");
            }

            return new Int24(bigInt);
        }

        public static Int24 Parse(string value, IFormatProvider provider) => new Int24(BigInteger.Parse("0" + value, provider));
        public static Int24 Parse(string value, NumberStyles style) => new Int24(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int24 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int24(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int24 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int24 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int24)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int24(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int24 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int24 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int24)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int24(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int24 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int24 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int24 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int24))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int24)}");
            }

            // Compare the underlying object
            return CompareTo((Int24)obj);
        }

        public bool Equals(Int24 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int24 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int24)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int24 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int24>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int24 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int24)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int24>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int24 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int40 : IIntegerBase, IComparable, IComparable<Int40>, IEquatable<Int40>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 5;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int40 MaxValue = new Int40(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int40 MinValue = new Int40(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int40 Zero = new Int40(0);
        public static readonly Int40 One = new Int40(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int40(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int40(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int40 left, Int40 right) => !(left == right);
        public static bool operator ==(Int40 left, Int40 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int40 left, Int40 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int40 left, Int40 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int40 left, Int40 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int40 left, Int40 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int40 operator %(Int40 dividend, Int40 divisor) => new Int40(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int40 operator +(Int40 left, Int40 right) => new Int40(left.ToBigInteger() + right.ToBigInteger());
        public static Int40 operator -(Int40 left, Int40 right) => new Int40(left.ToBigInteger() - right.ToBigInteger());
        public static Int40 operator *(Int40 left, Int40 right) => new Int40(left.ToBigInteger() * right.ToBigInteger());
        public static Int40 operator /(Int40 dividend, Int40 divisor) => new Int40(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int40 operator >>(Int40 value, int shift) => new Int40(value.ToBigInteger() >> shift);
        public static Int40 operator <<(Int40 value, int shift) => new Int40(value.ToBigInteger() << shift);
        public static Int40 operator |(Int40 left, Int40 right) => new Int40(left.ToBigInteger() | right.ToBigInteger());
        public static Int40 operator &(Int40 left, Int40 right) => new Int40(left.ToBigInteger() & right.ToBigInteger());
        public static Int40 operator ^(Int40 left, Int40 right) => new Int40(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int40 operator ++(Int40 value) => value + One;
        public static Int40 operator --(Int40 value) => value - One;
        public static Int40 operator ~(Int40 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int40(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int40 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int40 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int40 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int40 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int40 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int40 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static implicit operator long(Int40 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int40 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int40 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int40 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int40 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int40 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int40(sbyte value) => new Int40(value);
        public static implicit operator Int40(byte value) => new Int40(value);
        public static implicit operator Int40(short value) => new Int40(value);
        public static implicit operator Int40(ushort value) => new Int40(value);
        public static implicit operator Int40(int value) => new Int40(value);
        public static implicit operator Int40(uint value) => new Int40(value);
        public static explicit operator Int40(long value) => new Int40(value);
        public static explicit operator Int40(ulong value) => new Int40(value);
        public static explicit operator Int40(float value) => FromFloatingType(value);
        public static explicit operator Int40(double value) => FromFloatingType(value);
        public static explicit operator Int40(decimal value) => FromDecimalType(value);
        public static explicit operator Int40(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int40(BigInteger value) => new Int40(value);

        // Sibling Types -> This Type
        public static implicit operator Int40(Int24 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int48 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int56 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int72 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int80 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int88 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int96 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int104 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int112 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int120 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int128 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int136 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int144 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int152 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int160 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int168 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int176 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int184 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int192 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int200 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int208 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int216 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int224 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int232 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int240 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(Int248 value) => new Int40(value.ToBigInteger());
        public static implicit operator Int40(UInt24 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt40 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt48 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt56 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt72 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt80 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt88 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt96 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt104 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt112 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt120 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt128 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt136 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt144 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt152 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt160 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt168 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt176 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt184 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt192 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt200 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt208 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt216 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt224 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt232 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt240 value) => new Int40(value.ToBigInteger());
        public static explicit operator Int40(UInt248 value) => new Int40(value.ToBigInteger());

        public static Int40 DivRem(Int40 dividend, Int40 divisor, out Int40 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int40(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int40(remainderBigInt);
            return result;
        }

        public static Int40 Pow(Int40 value, int exponent) => new Int40(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int40 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int40 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int40)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int40)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int40)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int40)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int40)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int40)})");
            }

            return new Int40(bigInt);
        }

        static Int40 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int40)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int40)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int40)})");
            }

            return new Int40(bigInt);
        }

        public static Int40 Parse(string value, IFormatProvider provider) => new Int40(BigInteger.Parse("0" + value, provider));
        public static Int40 Parse(string value, NumberStyles style) => new Int40(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int40 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int40(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int40 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int40 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int40)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int40(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int40 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int40 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int40)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int40(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int40 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int40 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int40 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int40))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int40)}");
            }

            // Compare the underlying object
            return CompareTo((Int40)obj);
        }

        public bool Equals(Int40 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int40 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int40)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int40 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int40>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int40 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int40)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int40>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int40 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int48 : IIntegerBase, IComparable, IComparable<Int48>, IEquatable<Int48>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 6;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int48 MaxValue = new Int48(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int48 MinValue = new Int48(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int48 Zero = new Int48(0);
        public static readonly Int48 One = new Int48(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int48(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int48(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int48 left, Int48 right) => !(left == right);
        public static bool operator ==(Int48 left, Int48 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int48 left, Int48 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int48 left, Int48 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int48 left, Int48 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int48 left, Int48 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int48 operator %(Int48 dividend, Int48 divisor) => new Int48(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int48 operator +(Int48 left, Int48 right) => new Int48(left.ToBigInteger() + right.ToBigInteger());
        public static Int48 operator -(Int48 left, Int48 right) => new Int48(left.ToBigInteger() - right.ToBigInteger());
        public static Int48 operator *(Int48 left, Int48 right) => new Int48(left.ToBigInteger() * right.ToBigInteger());
        public static Int48 operator /(Int48 dividend, Int48 divisor) => new Int48(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int48 operator >>(Int48 value, int shift) => new Int48(value.ToBigInteger() >> shift);
        public static Int48 operator <<(Int48 value, int shift) => new Int48(value.ToBigInteger() << shift);
        public static Int48 operator |(Int48 left, Int48 right) => new Int48(left.ToBigInteger() | right.ToBigInteger());
        public static Int48 operator &(Int48 left, Int48 right) => new Int48(left.ToBigInteger() & right.ToBigInteger());
        public static Int48 operator ^(Int48 left, Int48 right) => new Int48(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int48 operator ++(Int48 value) => value + One;
        public static Int48 operator --(Int48 value) => value - One;
        public static Int48 operator ~(Int48 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int48(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int48 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int48 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int48 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int48 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int48 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int48 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static implicit operator long(Int48 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int48 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int48 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int48 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int48 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int48 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int48(sbyte value) => new Int48(value);
        public static implicit operator Int48(byte value) => new Int48(value);
        public static implicit operator Int48(short value) => new Int48(value);
        public static implicit operator Int48(ushort value) => new Int48(value);
        public static implicit operator Int48(int value) => new Int48(value);
        public static implicit operator Int48(uint value) => new Int48(value);
        public static explicit operator Int48(long value) => new Int48(value);
        public static explicit operator Int48(ulong value) => new Int48(value);
        public static explicit operator Int48(float value) => FromFloatingType(value);
        public static explicit operator Int48(double value) => FromFloatingType(value);
        public static explicit operator Int48(decimal value) => FromDecimalType(value);
        public static explicit operator Int48(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int48(BigInteger value) => new Int48(value);

        // Sibling Types -> This Type
        public static implicit operator Int48(Int24 value) => new Int48(value.ToBigInteger());
        public static implicit operator Int48(Int40 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int56 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int72 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int80 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int88 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int96 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int104 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int112 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int120 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int128 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int136 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int144 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int152 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int160 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int168 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int176 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int184 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int192 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int200 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int208 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int216 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int224 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int232 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int240 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(Int248 value) => new Int48(value.ToBigInteger());
        public static implicit operator Int48(UInt24 value) => new Int48(value.ToBigInteger());
        public static implicit operator Int48(UInt40 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt48 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt56 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt72 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt80 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt88 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt96 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt104 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt112 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt120 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt128 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt136 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt144 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt152 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt160 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt168 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt176 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt184 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt192 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt200 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt208 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt216 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt224 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt232 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt240 value) => new Int48(value.ToBigInteger());
        public static explicit operator Int48(UInt248 value) => new Int48(value.ToBigInteger());

        public static Int48 DivRem(Int48 dividend, Int48 divisor, out Int48 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int48(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int48(remainderBigInt);
            return result;
        }

        public static Int48 Pow(Int48 value, int exponent) => new Int48(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int48 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int48 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int48)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int48)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int48)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int48)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int48)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int48)})");
            }

            return new Int48(bigInt);
        }

        static Int48 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int48)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int48)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int48)})");
            }

            return new Int48(bigInt);
        }

        public static Int48 Parse(string value, IFormatProvider provider) => new Int48(BigInteger.Parse("0" + value, provider));
        public static Int48 Parse(string value, NumberStyles style) => new Int48(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int48 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int48(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int48 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int48 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int48)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int48(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int48 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int48 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int48)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int48(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int48 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int48 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int48 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int48))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int48)}");
            }

            // Compare the underlying object
            return CompareTo((Int48)obj);
        }

        public bool Equals(Int48 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int48 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int48)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int48 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int48>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int48 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int48)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int48>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int48 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int56 : IIntegerBase, IComparable, IComparable<Int56>, IEquatable<Int56>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 7;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int56 MaxValue = new Int56(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int56 MinValue = new Int56(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int56 Zero = new Int56(0);
        public static readonly Int56 One = new Int56(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int56(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int56(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int56 left, Int56 right) => !(left == right);
        public static bool operator ==(Int56 left, Int56 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int56 left, Int56 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int56 left, Int56 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int56 left, Int56 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int56 left, Int56 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int56 operator %(Int56 dividend, Int56 divisor) => new Int56(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int56 operator +(Int56 left, Int56 right) => new Int56(left.ToBigInteger() + right.ToBigInteger());
        public static Int56 operator -(Int56 left, Int56 right) => new Int56(left.ToBigInteger() - right.ToBigInteger());
        public static Int56 operator *(Int56 left, Int56 right) => new Int56(left.ToBigInteger() * right.ToBigInteger());
        public static Int56 operator /(Int56 dividend, Int56 divisor) => new Int56(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int56 operator >>(Int56 value, int shift) => new Int56(value.ToBigInteger() >> shift);
        public static Int56 operator <<(Int56 value, int shift) => new Int56(value.ToBigInteger() << shift);
        public static Int56 operator |(Int56 left, Int56 right) => new Int56(left.ToBigInteger() | right.ToBigInteger());
        public static Int56 operator &(Int56 left, Int56 right) => new Int56(left.ToBigInteger() & right.ToBigInteger());
        public static Int56 operator ^(Int56 left, Int56 right) => new Int56(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int56 operator ++(Int56 value) => value + One;
        public static Int56 operator --(Int56 value) => value - One;
        public static Int56 operator ~(Int56 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int56(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int56 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int56 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int56 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int56 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int56 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int56 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static implicit operator long(Int56 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int56 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int56 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int56 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int56 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int56 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int56(sbyte value) => new Int56(value);
        public static implicit operator Int56(byte value) => new Int56(value);
        public static implicit operator Int56(short value) => new Int56(value);
        public static implicit operator Int56(ushort value) => new Int56(value);
        public static implicit operator Int56(int value) => new Int56(value);
        public static implicit operator Int56(uint value) => new Int56(value);
        public static explicit operator Int56(long value) => new Int56(value);
        public static explicit operator Int56(ulong value) => new Int56(value);
        public static explicit operator Int56(float value) => FromFloatingType(value);
        public static explicit operator Int56(double value) => FromFloatingType(value);
        public static explicit operator Int56(decimal value) => FromDecimalType(value);
        public static explicit operator Int56(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int56(BigInteger value) => new Int56(value);

        // Sibling Types -> This Type
        public static implicit operator Int56(Int24 value) => new Int56(value.ToBigInteger());
        public static implicit operator Int56(Int40 value) => new Int56(value.ToBigInteger());
        public static implicit operator Int56(Int48 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int72 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int80 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int88 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int96 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int104 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int112 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int120 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int128 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int136 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int144 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int152 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int160 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int168 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int176 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int184 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int192 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int200 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int208 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int216 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int224 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int232 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int240 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(Int248 value) => new Int56(value.ToBigInteger());
        public static implicit operator Int56(UInt24 value) => new Int56(value.ToBigInteger());
        public static implicit operator Int56(UInt40 value) => new Int56(value.ToBigInteger());
        public static implicit operator Int56(UInt48 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt56 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt72 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt80 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt88 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt96 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt104 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt112 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt120 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt128 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt136 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt144 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt152 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt160 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt168 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt176 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt184 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt192 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt200 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt208 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt216 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt224 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt232 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt240 value) => new Int56(value.ToBigInteger());
        public static explicit operator Int56(UInt248 value) => new Int56(value.ToBigInteger());

        public static Int56 DivRem(Int56 dividend, Int56 divisor, out Int56 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int56(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int56(remainderBigInt);
            return result;
        }

        public static Int56 Pow(Int56 value, int exponent) => new Int56(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int56 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int56 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int56)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int56)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int56)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int56)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int56)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int56)})");
            }

            return new Int56(bigInt);
        }

        static Int56 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int56)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int56)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int56)})");
            }

            return new Int56(bigInt);
        }

        public static Int56 Parse(string value, IFormatProvider provider) => new Int56(BigInteger.Parse("0" + value, provider));
        public static Int56 Parse(string value, NumberStyles style) => new Int56(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int56 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int56(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int56 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int56 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int56)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int56(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int56 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int56 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int56)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int56(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int56 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int56 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int56 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int56))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int56)}");
            }

            // Compare the underlying object
            return CompareTo((Int56)obj);
        }

        public bool Equals(Int56 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int56 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int56)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int56 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int56>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int56 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int56)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int56>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int56 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int72 : IIntegerBase, IComparable, IComparable<Int72>, IEquatable<Int72>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 9;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int72 MaxValue = new Int72(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int72 MinValue = new Int72(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int72 Zero = new Int72(0);
        public static readonly Int72 One = new Int72(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int72(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int72(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int72 left, Int72 right) => !(left == right);
        public static bool operator ==(Int72 left, Int72 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int72 left, Int72 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int72 left, Int72 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int72 left, Int72 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int72 left, Int72 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int72 operator %(Int72 dividend, Int72 divisor) => new Int72(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int72 operator +(Int72 left, Int72 right) => new Int72(left.ToBigInteger() + right.ToBigInteger());
        public static Int72 operator -(Int72 left, Int72 right) => new Int72(left.ToBigInteger() - right.ToBigInteger());
        public static Int72 operator *(Int72 left, Int72 right) => new Int72(left.ToBigInteger() * right.ToBigInteger());
        public static Int72 operator /(Int72 dividend, Int72 divisor) => new Int72(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int72 operator >>(Int72 value, int shift) => new Int72(value.ToBigInteger() >> shift);
        public static Int72 operator <<(Int72 value, int shift) => new Int72(value.ToBigInteger() << shift);
        public static Int72 operator |(Int72 left, Int72 right) => new Int72(left.ToBigInteger() | right.ToBigInteger());
        public static Int72 operator &(Int72 left, Int72 right) => new Int72(left.ToBigInteger() & right.ToBigInteger());
        public static Int72 operator ^(Int72 left, Int72 right) => new Int72(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int72 operator ++(Int72 value) => value + One;
        public static Int72 operator --(Int72 value) => value - One;
        public static Int72 operator ~(Int72 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int72(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int72 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int72 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int72 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int72 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int72 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int72 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int72 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int72 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int72 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int72 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int72 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int72 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int72(sbyte value) => new Int72(value);
        public static implicit operator Int72(byte value) => new Int72(value);
        public static implicit operator Int72(short value) => new Int72(value);
        public static implicit operator Int72(ushort value) => new Int72(value);
        public static implicit operator Int72(int value) => new Int72(value);
        public static implicit operator Int72(uint value) => new Int72(value);
        public static implicit operator Int72(long value) => new Int72(value);
        public static implicit operator Int72(ulong value) => new Int72(value);
        public static explicit operator Int72(float value) => FromFloatingType(value);
        public static explicit operator Int72(double value) => FromFloatingType(value);
        public static explicit operator Int72(decimal value) => FromDecimalType(value);
        public static explicit operator Int72(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int72(BigInteger value) => new Int72(value);

        // Sibling Types -> This Type
        public static implicit operator Int72(Int24 value) => new Int72(value.ToBigInteger());
        public static implicit operator Int72(Int40 value) => new Int72(value.ToBigInteger());
        public static implicit operator Int72(Int48 value) => new Int72(value.ToBigInteger());
        public static implicit operator Int72(Int56 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int80 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int88 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int96 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int104 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int112 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int120 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int128 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int136 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int144 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int152 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int160 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int168 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int176 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int184 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int192 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int200 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int208 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int216 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int224 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int232 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int240 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(Int248 value) => new Int72(value.ToBigInteger());
        public static implicit operator Int72(UInt24 value) => new Int72(value.ToBigInteger());
        public static implicit operator Int72(UInt40 value) => new Int72(value.ToBigInteger());
        public static implicit operator Int72(UInt48 value) => new Int72(value.ToBigInteger());
        public static implicit operator Int72(UInt56 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt72 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt80 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt88 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt96 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt104 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt112 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt120 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt128 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt136 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt144 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt152 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt160 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt168 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt176 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt184 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt192 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt200 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt208 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt216 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt224 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt232 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt240 value) => new Int72(value.ToBigInteger());
        public static explicit operator Int72(UInt248 value) => new Int72(value.ToBigInteger());

        public static Int72 DivRem(Int72 dividend, Int72 divisor, out Int72 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int72(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int72(remainderBigInt);
            return result;
        }

        public static Int72 Pow(Int72 value, int exponent) => new Int72(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int72 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int72 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int72)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int72)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int72)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int72)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int72)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int72)})");
            }

            return new Int72(bigInt);
        }

        static Int72 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int72)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int72)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int72)})");
            }

            return new Int72(bigInt);
        }

        public static Int72 Parse(string value, IFormatProvider provider) => new Int72(BigInteger.Parse("0" + value, provider));
        public static Int72 Parse(string value, NumberStyles style) => new Int72(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int72 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int72(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int72 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int72 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int72)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int72(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int72 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int72 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int72)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int72(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int72 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int72 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int72 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int72))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int72)}");
            }

            // Compare the underlying object
            return CompareTo((Int72)obj);
        }

        public bool Equals(Int72 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int72 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int72)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int72 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int72>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int72 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int72)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int72>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int72 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int80 : IIntegerBase, IComparable, IComparable<Int80>, IEquatable<Int80>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 10;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int80 MaxValue = new Int80(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int80 MinValue = new Int80(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int80 Zero = new Int80(0);
        public static readonly Int80 One = new Int80(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int80(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int80(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int80 left, Int80 right) => !(left == right);
        public static bool operator ==(Int80 left, Int80 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int80 left, Int80 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int80 left, Int80 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int80 left, Int80 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int80 left, Int80 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int80 operator %(Int80 dividend, Int80 divisor) => new Int80(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int80 operator +(Int80 left, Int80 right) => new Int80(left.ToBigInteger() + right.ToBigInteger());
        public static Int80 operator -(Int80 left, Int80 right) => new Int80(left.ToBigInteger() - right.ToBigInteger());
        public static Int80 operator *(Int80 left, Int80 right) => new Int80(left.ToBigInteger() * right.ToBigInteger());
        public static Int80 operator /(Int80 dividend, Int80 divisor) => new Int80(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int80 operator >>(Int80 value, int shift) => new Int80(value.ToBigInteger() >> shift);
        public static Int80 operator <<(Int80 value, int shift) => new Int80(value.ToBigInteger() << shift);
        public static Int80 operator |(Int80 left, Int80 right) => new Int80(left.ToBigInteger() | right.ToBigInteger());
        public static Int80 operator &(Int80 left, Int80 right) => new Int80(left.ToBigInteger() & right.ToBigInteger());
        public static Int80 operator ^(Int80 left, Int80 right) => new Int80(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int80 operator ++(Int80 value) => value + One;
        public static Int80 operator --(Int80 value) => value - One;
        public static Int80 operator ~(Int80 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int80(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int80 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int80 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int80 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int80 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int80 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int80 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int80 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int80 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int80 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int80 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int80 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int80 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int80(sbyte value) => new Int80(value);
        public static implicit operator Int80(byte value) => new Int80(value);
        public static implicit operator Int80(short value) => new Int80(value);
        public static implicit operator Int80(ushort value) => new Int80(value);
        public static implicit operator Int80(int value) => new Int80(value);
        public static implicit operator Int80(uint value) => new Int80(value);
        public static implicit operator Int80(long value) => new Int80(value);
        public static implicit operator Int80(ulong value) => new Int80(value);
        public static explicit operator Int80(float value) => FromFloatingType(value);
        public static explicit operator Int80(double value) => FromFloatingType(value);
        public static explicit operator Int80(decimal value) => FromDecimalType(value);
        public static explicit operator Int80(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int80(BigInteger value) => new Int80(value);

        // Sibling Types -> This Type
        public static implicit operator Int80(Int24 value) => new Int80(value.ToBigInteger());
        public static implicit operator Int80(Int40 value) => new Int80(value.ToBigInteger());
        public static implicit operator Int80(Int48 value) => new Int80(value.ToBigInteger());
        public static implicit operator Int80(Int56 value) => new Int80(value.ToBigInteger());
        public static implicit operator Int80(Int72 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int88 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int96 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int104 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int112 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int120 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int128 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int136 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int144 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int152 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int160 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int168 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int176 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int184 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int192 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int200 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int208 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int216 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int224 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int232 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int240 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(Int248 value) => new Int80(value.ToBigInteger());
        public static implicit operator Int80(UInt24 value) => new Int80(value.ToBigInteger());
        public static implicit operator Int80(UInt40 value) => new Int80(value.ToBigInteger());
        public static implicit operator Int80(UInt48 value) => new Int80(value.ToBigInteger());
        public static implicit operator Int80(UInt56 value) => new Int80(value.ToBigInteger());
        public static implicit operator Int80(UInt72 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt80 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt88 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt96 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt104 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt112 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt120 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt128 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt136 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt144 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt152 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt160 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt168 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt176 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt184 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt192 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt200 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt208 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt216 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt224 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt232 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt240 value) => new Int80(value.ToBigInteger());
        public static explicit operator Int80(UInt248 value) => new Int80(value.ToBigInteger());

        public static Int80 DivRem(Int80 dividend, Int80 divisor, out Int80 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int80(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int80(remainderBigInt);
            return result;
        }

        public static Int80 Pow(Int80 value, int exponent) => new Int80(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int80 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int80 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int80)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int80)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int80)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int80)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int80)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int80)})");
            }

            return new Int80(bigInt);
        }

        static Int80 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int80)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int80)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int80)})");
            }

            return new Int80(bigInt);
        }

        public static Int80 Parse(string value, IFormatProvider provider) => new Int80(BigInteger.Parse("0" + value, provider));
        public static Int80 Parse(string value, NumberStyles style) => new Int80(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int80 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int80(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int80 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int80 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int80)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int80(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int80 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int80 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int80)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int80(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int80 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int80 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int80 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int80))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int80)}");
            }

            // Compare the underlying object
            return CompareTo((Int80)obj);
        }

        public bool Equals(Int80 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int80 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int80)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int80 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int80>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int80 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int80)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int80>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int80 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int88 : IIntegerBase, IComparable, IComparable<Int88>, IEquatable<Int88>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 11;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int88 MaxValue = new Int88(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int88 MinValue = new Int88(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int88 Zero = new Int88(0);
        public static readonly Int88 One = new Int88(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int88(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int88(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int88 left, Int88 right) => !(left == right);
        public static bool operator ==(Int88 left, Int88 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int88 left, Int88 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int88 left, Int88 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int88 left, Int88 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int88 left, Int88 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int88 operator %(Int88 dividend, Int88 divisor) => new Int88(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int88 operator +(Int88 left, Int88 right) => new Int88(left.ToBigInteger() + right.ToBigInteger());
        public static Int88 operator -(Int88 left, Int88 right) => new Int88(left.ToBigInteger() - right.ToBigInteger());
        public static Int88 operator *(Int88 left, Int88 right) => new Int88(left.ToBigInteger() * right.ToBigInteger());
        public static Int88 operator /(Int88 dividend, Int88 divisor) => new Int88(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int88 operator >>(Int88 value, int shift) => new Int88(value.ToBigInteger() >> shift);
        public static Int88 operator <<(Int88 value, int shift) => new Int88(value.ToBigInteger() << shift);
        public static Int88 operator |(Int88 left, Int88 right) => new Int88(left.ToBigInteger() | right.ToBigInteger());
        public static Int88 operator &(Int88 left, Int88 right) => new Int88(left.ToBigInteger() & right.ToBigInteger());
        public static Int88 operator ^(Int88 left, Int88 right) => new Int88(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int88 operator ++(Int88 value) => value + One;
        public static Int88 operator --(Int88 value) => value - One;
        public static Int88 operator ~(Int88 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int88(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int88 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int88 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int88 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int88 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int88 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int88 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int88 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int88 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int88 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int88 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int88 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int88 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int88(sbyte value) => new Int88(value);
        public static implicit operator Int88(byte value) => new Int88(value);
        public static implicit operator Int88(short value) => new Int88(value);
        public static implicit operator Int88(ushort value) => new Int88(value);
        public static implicit operator Int88(int value) => new Int88(value);
        public static implicit operator Int88(uint value) => new Int88(value);
        public static implicit operator Int88(long value) => new Int88(value);
        public static implicit operator Int88(ulong value) => new Int88(value);
        public static explicit operator Int88(float value) => FromFloatingType(value);
        public static explicit operator Int88(double value) => FromFloatingType(value);
        public static explicit operator Int88(decimal value) => FromDecimalType(value);
        public static explicit operator Int88(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int88(BigInteger value) => new Int88(value);

        // Sibling Types -> This Type
        public static implicit operator Int88(Int24 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(Int40 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(Int48 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(Int56 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(Int72 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(Int80 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int96 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int104 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int112 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int120 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int128 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int136 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int144 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int152 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int160 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int168 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int176 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int184 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int192 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int200 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int208 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int216 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int224 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int232 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int240 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(Int248 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(UInt24 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(UInt40 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(UInt48 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(UInt56 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(UInt72 value) => new Int88(value.ToBigInteger());
        public static implicit operator Int88(UInt80 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt88 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt96 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt104 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt112 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt120 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt128 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt136 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt144 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt152 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt160 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt168 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt176 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt184 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt192 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt200 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt208 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt216 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt224 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt232 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt240 value) => new Int88(value.ToBigInteger());
        public static explicit operator Int88(UInt248 value) => new Int88(value.ToBigInteger());

        public static Int88 DivRem(Int88 dividend, Int88 divisor, out Int88 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int88(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int88(remainderBigInt);
            return result;
        }

        public static Int88 Pow(Int88 value, int exponent) => new Int88(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int88 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int88 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int88)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int88)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int88)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int88)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int88)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int88)})");
            }

            return new Int88(bigInt);
        }

        static Int88 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int88)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int88)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int88)})");
            }

            return new Int88(bigInt);
        }

        public static Int88 Parse(string value, IFormatProvider provider) => new Int88(BigInteger.Parse("0" + value, provider));
        public static Int88 Parse(string value, NumberStyles style) => new Int88(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int88 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int88(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int88 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int88 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int88)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int88(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int88 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int88 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int88)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int88(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int88 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int88 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int88 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int88))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int88)}");
            }

            // Compare the underlying object
            return CompareTo((Int88)obj);
        }

        public bool Equals(Int88 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int88 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int88)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int88 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int88>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int88 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int88)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int88>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int88 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int96 : IIntegerBase, IComparable, IComparable<Int96>, IEquatable<Int96>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 12;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int96 MaxValue = new Int96(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int96 MinValue = new Int96(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int96 Zero = new Int96(0);
        public static readonly Int96 One = new Int96(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int96(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int96(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int96 left, Int96 right) => !(left == right);
        public static bool operator ==(Int96 left, Int96 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int96 left, Int96 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int96 left, Int96 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int96 left, Int96 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int96 left, Int96 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int96 operator %(Int96 dividend, Int96 divisor) => new Int96(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int96 operator +(Int96 left, Int96 right) => new Int96(left.ToBigInteger() + right.ToBigInteger());
        public static Int96 operator -(Int96 left, Int96 right) => new Int96(left.ToBigInteger() - right.ToBigInteger());
        public static Int96 operator *(Int96 left, Int96 right) => new Int96(left.ToBigInteger() * right.ToBigInteger());
        public static Int96 operator /(Int96 dividend, Int96 divisor) => new Int96(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int96 operator >>(Int96 value, int shift) => new Int96(value.ToBigInteger() >> shift);
        public static Int96 operator <<(Int96 value, int shift) => new Int96(value.ToBigInteger() << shift);
        public static Int96 operator |(Int96 left, Int96 right) => new Int96(left.ToBigInteger() | right.ToBigInteger());
        public static Int96 operator &(Int96 left, Int96 right) => new Int96(left.ToBigInteger() & right.ToBigInteger());
        public static Int96 operator ^(Int96 left, Int96 right) => new Int96(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int96 operator ++(Int96 value) => value + One;
        public static Int96 operator --(Int96 value) => value - One;
        public static Int96 operator ~(Int96 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int96(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int96 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int96 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int96 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int96 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int96 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int96 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int96 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int96 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int96 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int96 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int96 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int96 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int96(sbyte value) => new Int96(value);
        public static implicit operator Int96(byte value) => new Int96(value);
        public static implicit operator Int96(short value) => new Int96(value);
        public static implicit operator Int96(ushort value) => new Int96(value);
        public static implicit operator Int96(int value) => new Int96(value);
        public static implicit operator Int96(uint value) => new Int96(value);
        public static implicit operator Int96(long value) => new Int96(value);
        public static implicit operator Int96(ulong value) => new Int96(value);
        public static explicit operator Int96(float value) => FromFloatingType(value);
        public static explicit operator Int96(double value) => FromFloatingType(value);
        public static explicit operator Int96(decimal value) => FromDecimalType(value);
        public static explicit operator Int96(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int96(BigInteger value) => new Int96(value);

        // Sibling Types -> This Type
        public static implicit operator Int96(Int24 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(Int40 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(Int48 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(Int56 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(Int72 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(Int80 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(Int88 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int104 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int112 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int120 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int128 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int136 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int144 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int152 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int160 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int168 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int176 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int184 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int192 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int200 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int208 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int216 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int224 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int232 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int240 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(Int248 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(UInt24 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(UInt40 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(UInt48 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(UInt56 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(UInt72 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(UInt80 value) => new Int96(value.ToBigInteger());
        public static implicit operator Int96(UInt88 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt96 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt104 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt112 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt120 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt128 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt136 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt144 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt152 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt160 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt168 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt176 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt184 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt192 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt200 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt208 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt216 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt224 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt232 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt240 value) => new Int96(value.ToBigInteger());
        public static explicit operator Int96(UInt248 value) => new Int96(value.ToBigInteger());

        public static Int96 DivRem(Int96 dividend, Int96 divisor, out Int96 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int96(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int96(remainderBigInt);
            return result;
        }

        public static Int96 Pow(Int96 value, int exponent) => new Int96(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int96 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int96 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int96)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int96)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int96)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int96)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int96)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int96)})");
            }

            return new Int96(bigInt);
        }

        static Int96 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int96)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int96)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int96)})");
            }

            return new Int96(bigInt);
        }

        public static Int96 Parse(string value, IFormatProvider provider) => new Int96(BigInteger.Parse("0" + value, provider));
        public static Int96 Parse(string value, NumberStyles style) => new Int96(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int96 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int96(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int96 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int96 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int96)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int96(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int96 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int96 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int96)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int96(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int96 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int96 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int96 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int96))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int96)}");
            }

            // Compare the underlying object
            return CompareTo((Int96)obj);
        }

        public bool Equals(Int96 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int96 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int96)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int96 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int96>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int96 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int96)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int96>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int96 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int104 : IIntegerBase, IComparable, IComparable<Int104>, IEquatable<Int104>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 13;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int104 MaxValue = new Int104(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int104 MinValue = new Int104(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int104 Zero = new Int104(0);
        public static readonly Int104 One = new Int104(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int104(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int104(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int104 left, Int104 right) => !(left == right);
        public static bool operator ==(Int104 left, Int104 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int104 left, Int104 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int104 left, Int104 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int104 left, Int104 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int104 left, Int104 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int104 operator %(Int104 dividend, Int104 divisor) => new Int104(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int104 operator +(Int104 left, Int104 right) => new Int104(left.ToBigInteger() + right.ToBigInteger());
        public static Int104 operator -(Int104 left, Int104 right) => new Int104(left.ToBigInteger() - right.ToBigInteger());
        public static Int104 operator *(Int104 left, Int104 right) => new Int104(left.ToBigInteger() * right.ToBigInteger());
        public static Int104 operator /(Int104 dividend, Int104 divisor) => new Int104(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int104 operator >>(Int104 value, int shift) => new Int104(value.ToBigInteger() >> shift);
        public static Int104 operator <<(Int104 value, int shift) => new Int104(value.ToBigInteger() << shift);
        public static Int104 operator |(Int104 left, Int104 right) => new Int104(left.ToBigInteger() | right.ToBigInteger());
        public static Int104 operator &(Int104 left, Int104 right) => new Int104(left.ToBigInteger() & right.ToBigInteger());
        public static Int104 operator ^(Int104 left, Int104 right) => new Int104(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int104 operator ++(Int104 value) => value + One;
        public static Int104 operator --(Int104 value) => value - One;
        public static Int104 operator ~(Int104 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int104(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int104 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int104 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int104 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int104 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int104 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int104 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int104 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int104 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int104 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int104 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int104 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int104 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int104(sbyte value) => new Int104(value);
        public static implicit operator Int104(byte value) => new Int104(value);
        public static implicit operator Int104(short value) => new Int104(value);
        public static implicit operator Int104(ushort value) => new Int104(value);
        public static implicit operator Int104(int value) => new Int104(value);
        public static implicit operator Int104(uint value) => new Int104(value);
        public static implicit operator Int104(long value) => new Int104(value);
        public static implicit operator Int104(ulong value) => new Int104(value);
        public static explicit operator Int104(float value) => FromFloatingType(value);
        public static explicit operator Int104(double value) => FromFloatingType(value);
        public static explicit operator Int104(decimal value) => FromDecimalType(value);
        public static explicit operator Int104(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int104(BigInteger value) => new Int104(value);

        // Sibling Types -> This Type
        public static implicit operator Int104(Int24 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(Int40 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(Int48 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(Int56 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(Int72 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(Int80 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(Int88 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(Int96 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int112 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int120 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int128 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int136 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int144 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int152 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int160 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int168 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int176 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int184 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int192 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int200 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int208 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int216 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int224 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int232 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int240 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(Int248 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(UInt24 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(UInt40 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(UInt48 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(UInt56 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(UInt72 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(UInt80 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(UInt88 value) => new Int104(value.ToBigInteger());
        public static implicit operator Int104(UInt96 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt104 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt112 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt120 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt128 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt136 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt144 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt152 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt160 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt168 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt176 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt184 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt192 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt200 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt208 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt216 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt224 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt232 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt240 value) => new Int104(value.ToBigInteger());
        public static explicit operator Int104(UInt248 value) => new Int104(value.ToBigInteger());

        public static Int104 DivRem(Int104 dividend, Int104 divisor, out Int104 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int104(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int104(remainderBigInt);
            return result;
        }

        public static Int104 Pow(Int104 value, int exponent) => new Int104(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int104 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int104 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int104)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int104)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int104)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int104)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int104)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int104)})");
            }

            return new Int104(bigInt);
        }

        static Int104 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int104)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int104)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int104)})");
            }

            return new Int104(bigInt);
        }

        public static Int104 Parse(string value, IFormatProvider provider) => new Int104(BigInteger.Parse("0" + value, provider));
        public static Int104 Parse(string value, NumberStyles style) => new Int104(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int104 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int104(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int104 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int104 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int104)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int104(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int104 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int104 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int104)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int104(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int104 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int104 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int104 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int104))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int104)}");
            }

            // Compare the underlying object
            return CompareTo((Int104)obj);
        }

        public bool Equals(Int104 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int104 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int104)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int104 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int104>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int104 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int104)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int104>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int104 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int112 : IIntegerBase, IComparable, IComparable<Int112>, IEquatable<Int112>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 14;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int112 MaxValue = new Int112(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int112 MinValue = new Int112(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int112 Zero = new Int112(0);
        public static readonly Int112 One = new Int112(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int112(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int112(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int112 left, Int112 right) => !(left == right);
        public static bool operator ==(Int112 left, Int112 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int112 left, Int112 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int112 left, Int112 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int112 left, Int112 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int112 left, Int112 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int112 operator %(Int112 dividend, Int112 divisor) => new Int112(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int112 operator +(Int112 left, Int112 right) => new Int112(left.ToBigInteger() + right.ToBigInteger());
        public static Int112 operator -(Int112 left, Int112 right) => new Int112(left.ToBigInteger() - right.ToBigInteger());
        public static Int112 operator *(Int112 left, Int112 right) => new Int112(left.ToBigInteger() * right.ToBigInteger());
        public static Int112 operator /(Int112 dividend, Int112 divisor) => new Int112(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int112 operator >>(Int112 value, int shift) => new Int112(value.ToBigInteger() >> shift);
        public static Int112 operator <<(Int112 value, int shift) => new Int112(value.ToBigInteger() << shift);
        public static Int112 operator |(Int112 left, Int112 right) => new Int112(left.ToBigInteger() | right.ToBigInteger());
        public static Int112 operator &(Int112 left, Int112 right) => new Int112(left.ToBigInteger() & right.ToBigInteger());
        public static Int112 operator ^(Int112 left, Int112 right) => new Int112(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int112 operator ++(Int112 value) => value + One;
        public static Int112 operator --(Int112 value) => value - One;
        public static Int112 operator ~(Int112 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int112(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int112 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int112 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int112 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int112 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int112 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int112 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int112 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int112 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int112 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int112 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int112 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int112 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int112(sbyte value) => new Int112(value);
        public static implicit operator Int112(byte value) => new Int112(value);
        public static implicit operator Int112(short value) => new Int112(value);
        public static implicit operator Int112(ushort value) => new Int112(value);
        public static implicit operator Int112(int value) => new Int112(value);
        public static implicit operator Int112(uint value) => new Int112(value);
        public static implicit operator Int112(long value) => new Int112(value);
        public static implicit operator Int112(ulong value) => new Int112(value);
        public static explicit operator Int112(float value) => FromFloatingType(value);
        public static explicit operator Int112(double value) => FromFloatingType(value);
        public static explicit operator Int112(decimal value) => FromDecimalType(value);
        public static explicit operator Int112(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int112(BigInteger value) => new Int112(value);

        // Sibling Types -> This Type
        public static implicit operator Int112(Int24 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(Int40 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(Int48 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(Int56 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(Int72 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(Int80 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(Int88 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(Int96 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(Int104 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int120 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int128 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int136 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int144 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int152 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int160 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int168 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int176 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int184 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int192 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int200 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int208 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int216 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int224 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int232 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int240 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(Int248 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(UInt24 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(UInt40 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(UInt48 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(UInt56 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(UInt72 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(UInt80 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(UInt88 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(UInt96 value) => new Int112(value.ToBigInteger());
        public static implicit operator Int112(UInt104 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt112 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt120 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt128 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt136 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt144 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt152 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt160 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt168 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt176 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt184 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt192 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt200 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt208 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt216 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt224 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt232 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt240 value) => new Int112(value.ToBigInteger());
        public static explicit operator Int112(UInt248 value) => new Int112(value.ToBigInteger());

        public static Int112 DivRem(Int112 dividend, Int112 divisor, out Int112 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int112(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int112(remainderBigInt);
            return result;
        }

        public static Int112 Pow(Int112 value, int exponent) => new Int112(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int112 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int112 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int112)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int112)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int112)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int112)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int112)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int112)})");
            }

            return new Int112(bigInt);
        }

        static Int112 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int112)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int112)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int112)})");
            }

            return new Int112(bigInt);
        }

        public static Int112 Parse(string value, IFormatProvider provider) => new Int112(BigInteger.Parse("0" + value, provider));
        public static Int112 Parse(string value, NumberStyles style) => new Int112(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int112 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int112(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int112 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int112 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int112)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int112(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int112 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int112 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int112)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int112(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int112 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int112 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int112 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int112))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int112)}");
            }

            // Compare the underlying object
            return CompareTo((Int112)obj);
        }

        public bool Equals(Int112 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int112 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int112)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int112 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int112>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int112 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int112)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int112>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int112 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int120 : IIntegerBase, IComparable, IComparable<Int120>, IEquatable<Int120>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 15;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int120 MaxValue = new Int120(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int120 MinValue = new Int120(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int120 Zero = new Int120(0);
        public static readonly Int120 One = new Int120(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int120(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int120(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int120 left, Int120 right) => !(left == right);
        public static bool operator ==(Int120 left, Int120 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int120 left, Int120 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int120 left, Int120 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int120 left, Int120 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int120 left, Int120 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int120 operator %(Int120 dividend, Int120 divisor) => new Int120(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int120 operator +(Int120 left, Int120 right) => new Int120(left.ToBigInteger() + right.ToBigInteger());
        public static Int120 operator -(Int120 left, Int120 right) => new Int120(left.ToBigInteger() - right.ToBigInteger());
        public static Int120 operator *(Int120 left, Int120 right) => new Int120(left.ToBigInteger() * right.ToBigInteger());
        public static Int120 operator /(Int120 dividend, Int120 divisor) => new Int120(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int120 operator >>(Int120 value, int shift) => new Int120(value.ToBigInteger() >> shift);
        public static Int120 operator <<(Int120 value, int shift) => new Int120(value.ToBigInteger() << shift);
        public static Int120 operator |(Int120 left, Int120 right) => new Int120(left.ToBigInteger() | right.ToBigInteger());
        public static Int120 operator &(Int120 left, Int120 right) => new Int120(left.ToBigInteger() & right.ToBigInteger());
        public static Int120 operator ^(Int120 left, Int120 right) => new Int120(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int120 operator ++(Int120 value) => value + One;
        public static Int120 operator --(Int120 value) => value - One;
        public static Int120 operator ~(Int120 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int120(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int120 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int120 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int120 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int120 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int120 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int120 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int120 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int120 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int120 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int120 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int120 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int120 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int120(sbyte value) => new Int120(value);
        public static implicit operator Int120(byte value) => new Int120(value);
        public static implicit operator Int120(short value) => new Int120(value);
        public static implicit operator Int120(ushort value) => new Int120(value);
        public static implicit operator Int120(int value) => new Int120(value);
        public static implicit operator Int120(uint value) => new Int120(value);
        public static implicit operator Int120(long value) => new Int120(value);
        public static implicit operator Int120(ulong value) => new Int120(value);
        public static explicit operator Int120(float value) => FromFloatingType(value);
        public static explicit operator Int120(double value) => FromFloatingType(value);
        public static explicit operator Int120(decimal value) => FromDecimalType(value);
        public static explicit operator Int120(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int120(BigInteger value) => new Int120(value);

        // Sibling Types -> This Type
        public static implicit operator Int120(Int24 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(Int40 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(Int48 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(Int56 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(Int72 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(Int80 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(Int88 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(Int96 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(Int104 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(Int112 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int128 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int136 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int144 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int152 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int160 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int168 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int176 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int184 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int192 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int200 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int208 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int216 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int224 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int232 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int240 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(Int248 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(UInt24 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(UInt40 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(UInt48 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(UInt56 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(UInt72 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(UInt80 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(UInt88 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(UInt96 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(UInt104 value) => new Int120(value.ToBigInteger());
        public static implicit operator Int120(UInt112 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt120 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt128 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt136 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt144 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt152 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt160 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt168 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt176 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt184 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt192 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt200 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt208 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt216 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt224 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt232 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt240 value) => new Int120(value.ToBigInteger());
        public static explicit operator Int120(UInt248 value) => new Int120(value.ToBigInteger());

        public static Int120 DivRem(Int120 dividend, Int120 divisor, out Int120 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int120(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int120(remainderBigInt);
            return result;
        }

        public static Int120 Pow(Int120 value, int exponent) => new Int120(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int120 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int120 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int120)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int120)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int120)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int120)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int120)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int120)})");
            }

            return new Int120(bigInt);
        }

        static Int120 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int120)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int120)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int120)})");
            }

            return new Int120(bigInt);
        }

        public static Int120 Parse(string value, IFormatProvider provider) => new Int120(BigInteger.Parse("0" + value, provider));
        public static Int120 Parse(string value, NumberStyles style) => new Int120(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int120 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int120(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int120 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int120 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int120)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int120(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int120 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int120 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int120)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int120(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int120 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int120 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int120 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int120))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int120)}");
            }

            // Compare the underlying object
            return CompareTo((Int120)obj);
        }

        public bool Equals(Int120 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int120 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int120)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int120 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int120>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int120 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int120)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int120>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int120 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int128 : IIntegerBase, IComparable, IComparable<Int128>, IEquatable<Int128>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 16;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int128 MaxValue = new Int128(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int128 MinValue = new Int128(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int128 Zero = new Int128(0);
        public static readonly Int128 One = new Int128(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int128(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int128(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int128 left, Int128 right) => !(left == right);
        public static bool operator ==(Int128 left, Int128 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int128 left, Int128 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int128 left, Int128 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int128 left, Int128 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int128 left, Int128 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int128 operator %(Int128 dividend, Int128 divisor) => new Int128(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int128 operator +(Int128 left, Int128 right) => new Int128(left.ToBigInteger() + right.ToBigInteger());
        public static Int128 operator -(Int128 left, Int128 right) => new Int128(left.ToBigInteger() - right.ToBigInteger());
        public static Int128 operator *(Int128 left, Int128 right) => new Int128(left.ToBigInteger() * right.ToBigInteger());
        public static Int128 operator /(Int128 dividend, Int128 divisor) => new Int128(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int128 operator >>(Int128 value, int shift) => new Int128(value.ToBigInteger() >> shift);
        public static Int128 operator <<(Int128 value, int shift) => new Int128(value.ToBigInteger() << shift);
        public static Int128 operator |(Int128 left, Int128 right) => new Int128(left.ToBigInteger() | right.ToBigInteger());
        public static Int128 operator &(Int128 left, Int128 right) => new Int128(left.ToBigInteger() & right.ToBigInteger());
        public static Int128 operator ^(Int128 left, Int128 right) => new Int128(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int128 operator ++(Int128 value) => value + One;
        public static Int128 operator --(Int128 value) => value - One;
        public static Int128 operator ~(Int128 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int128(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int128 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int128 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int128 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int128 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int128 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int128 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int128 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int128 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int128 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int128 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int128 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int128 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int128(sbyte value) => new Int128(value);
        public static implicit operator Int128(byte value) => new Int128(value);
        public static implicit operator Int128(short value) => new Int128(value);
        public static implicit operator Int128(ushort value) => new Int128(value);
        public static implicit operator Int128(int value) => new Int128(value);
        public static implicit operator Int128(uint value) => new Int128(value);
        public static implicit operator Int128(long value) => new Int128(value);
        public static implicit operator Int128(ulong value) => new Int128(value);
        public static explicit operator Int128(float value) => FromFloatingType(value);
        public static explicit operator Int128(double value) => FromFloatingType(value);
        public static explicit operator Int128(decimal value) => FromDecimalType(value);
        public static explicit operator Int128(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int128(BigInteger value) => new Int128(value);

        // Sibling Types -> This Type
        public static implicit operator Int128(Int24 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(Int40 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(Int48 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(Int56 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(Int72 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(Int80 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(Int88 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(Int96 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(Int104 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(Int112 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(Int120 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int136 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int144 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int152 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int160 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int168 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int176 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int184 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int192 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int200 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int208 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int216 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int224 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int232 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int240 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(Int248 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt24 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt40 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt48 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt56 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt72 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt80 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt88 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt96 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt104 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt112 value) => new Int128(value.ToBigInteger());
        public static implicit operator Int128(UInt120 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt128 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt136 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt144 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt152 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt160 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt168 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt176 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt184 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt192 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt200 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt208 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt216 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt224 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt232 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt240 value) => new Int128(value.ToBigInteger());
        public static explicit operator Int128(UInt248 value) => new Int128(value.ToBigInteger());

        public static Int128 DivRem(Int128 dividend, Int128 divisor, out Int128 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int128(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int128(remainderBigInt);
            return result;
        }

        public static Int128 Pow(Int128 value, int exponent) => new Int128(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int128 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int128 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int128)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int128)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int128)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int128)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int128)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int128)})");
            }

            return new Int128(bigInt);
        }

        static Int128 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int128)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int128)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int128)})");
            }

            return new Int128(bigInt);
        }

        public static Int128 Parse(string value, IFormatProvider provider) => new Int128(BigInteger.Parse("0" + value, provider));
        public static Int128 Parse(string value, NumberStyles style) => new Int128(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int128 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int128(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int128 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int128 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int128)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int128(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int128 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int128 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int128)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int128(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int128 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int128 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int128 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int128))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int128)}");
            }

            // Compare the underlying object
            return CompareTo((Int128)obj);
        }

        public bool Equals(Int128 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int128 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int128)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int128 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int128>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int128 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int128)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int128>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int128 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int136 : IIntegerBase, IComparable, IComparable<Int136>, IEquatable<Int136>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 17;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int136 MaxValue = new Int136(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int136 MinValue = new Int136(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int136 Zero = new Int136(0);
        public static readonly Int136 One = new Int136(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int136(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int136(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int136 left, Int136 right) => !(left == right);
        public static bool operator ==(Int136 left, Int136 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int136 left, Int136 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int136 left, Int136 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int136 left, Int136 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int136 left, Int136 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int136 operator %(Int136 dividend, Int136 divisor) => new Int136(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int136 operator +(Int136 left, Int136 right) => new Int136(left.ToBigInteger() + right.ToBigInteger());
        public static Int136 operator -(Int136 left, Int136 right) => new Int136(left.ToBigInteger() - right.ToBigInteger());
        public static Int136 operator *(Int136 left, Int136 right) => new Int136(left.ToBigInteger() * right.ToBigInteger());
        public static Int136 operator /(Int136 dividend, Int136 divisor) => new Int136(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int136 operator >>(Int136 value, int shift) => new Int136(value.ToBigInteger() >> shift);
        public static Int136 operator <<(Int136 value, int shift) => new Int136(value.ToBigInteger() << shift);
        public static Int136 operator |(Int136 left, Int136 right) => new Int136(left.ToBigInteger() | right.ToBigInteger());
        public static Int136 operator &(Int136 left, Int136 right) => new Int136(left.ToBigInteger() & right.ToBigInteger());
        public static Int136 operator ^(Int136 left, Int136 right) => new Int136(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int136 operator ++(Int136 value) => value + One;
        public static Int136 operator --(Int136 value) => value - One;
        public static Int136 operator ~(Int136 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int136(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int136 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int136 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int136 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int136 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int136 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int136 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int136 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int136 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int136 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int136 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int136 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int136 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int136(sbyte value) => new Int136(value);
        public static implicit operator Int136(byte value) => new Int136(value);
        public static implicit operator Int136(short value) => new Int136(value);
        public static implicit operator Int136(ushort value) => new Int136(value);
        public static implicit operator Int136(int value) => new Int136(value);
        public static implicit operator Int136(uint value) => new Int136(value);
        public static implicit operator Int136(long value) => new Int136(value);
        public static implicit operator Int136(ulong value) => new Int136(value);
        public static explicit operator Int136(float value) => FromFloatingType(value);
        public static explicit operator Int136(double value) => FromFloatingType(value);
        public static explicit operator Int136(decimal value) => FromDecimalType(value);
        public static explicit operator Int136(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int136(BigInteger value) => new Int136(value);

        // Sibling Types -> This Type
        public static implicit operator Int136(Int24 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int40 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int48 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int56 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int72 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int80 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int88 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int96 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int104 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int112 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int120 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(Int128 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int144 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int152 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int160 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int168 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int176 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int184 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int192 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int200 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int208 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int216 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int224 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int232 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int240 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(Int248 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt24 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt40 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt48 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt56 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt72 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt80 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt88 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt96 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt104 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt112 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt120 value) => new Int136(value.ToBigInteger());
        public static implicit operator Int136(UInt128 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt136 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt144 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt152 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt160 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt168 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt176 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt184 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt192 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt200 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt208 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt216 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt224 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt232 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt240 value) => new Int136(value.ToBigInteger());
        public static explicit operator Int136(UInt248 value) => new Int136(value.ToBigInteger());

        public static Int136 DivRem(Int136 dividend, Int136 divisor, out Int136 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int136(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int136(remainderBigInt);
            return result;
        }

        public static Int136 Pow(Int136 value, int exponent) => new Int136(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int136 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int136 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int136)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int136)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int136)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int136)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int136)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int136)})");
            }

            return new Int136(bigInt);
        }

        static Int136 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int136)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int136)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int136)})");
            }

            return new Int136(bigInt);
        }

        public static Int136 Parse(string value, IFormatProvider provider) => new Int136(BigInteger.Parse("0" + value, provider));
        public static Int136 Parse(string value, NumberStyles style) => new Int136(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int136 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int136(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int136 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int136 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int136)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int136(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int136 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int136 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int136)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int136(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int136 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int136 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int136 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int136))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int136)}");
            }

            // Compare the underlying object
            return CompareTo((Int136)obj);
        }

        public bool Equals(Int136 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int136 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int136)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int136 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int136>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int136 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int136)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int136>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int136 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int144 : IIntegerBase, IComparable, IComparable<Int144>, IEquatable<Int144>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 18;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int144 MaxValue = new Int144(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int144 MinValue = new Int144(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int144 Zero = new Int144(0);
        public static readonly Int144 One = new Int144(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int144(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int144(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int144 left, Int144 right) => !(left == right);
        public static bool operator ==(Int144 left, Int144 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int144 left, Int144 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int144 left, Int144 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int144 left, Int144 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int144 left, Int144 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int144 operator %(Int144 dividend, Int144 divisor) => new Int144(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int144 operator +(Int144 left, Int144 right) => new Int144(left.ToBigInteger() + right.ToBigInteger());
        public static Int144 operator -(Int144 left, Int144 right) => new Int144(left.ToBigInteger() - right.ToBigInteger());
        public static Int144 operator *(Int144 left, Int144 right) => new Int144(left.ToBigInteger() * right.ToBigInteger());
        public static Int144 operator /(Int144 dividend, Int144 divisor) => new Int144(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int144 operator >>(Int144 value, int shift) => new Int144(value.ToBigInteger() >> shift);
        public static Int144 operator <<(Int144 value, int shift) => new Int144(value.ToBigInteger() << shift);
        public static Int144 operator |(Int144 left, Int144 right) => new Int144(left.ToBigInteger() | right.ToBigInteger());
        public static Int144 operator &(Int144 left, Int144 right) => new Int144(left.ToBigInteger() & right.ToBigInteger());
        public static Int144 operator ^(Int144 left, Int144 right) => new Int144(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int144 operator ++(Int144 value) => value + One;
        public static Int144 operator --(Int144 value) => value - One;
        public static Int144 operator ~(Int144 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int144(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int144 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int144 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int144 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int144 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int144 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int144 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int144 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int144 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int144 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int144 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int144 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int144 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int144(sbyte value) => new Int144(value);
        public static implicit operator Int144(byte value) => new Int144(value);
        public static implicit operator Int144(short value) => new Int144(value);
        public static implicit operator Int144(ushort value) => new Int144(value);
        public static implicit operator Int144(int value) => new Int144(value);
        public static implicit operator Int144(uint value) => new Int144(value);
        public static implicit operator Int144(long value) => new Int144(value);
        public static implicit operator Int144(ulong value) => new Int144(value);
        public static explicit operator Int144(float value) => FromFloatingType(value);
        public static explicit operator Int144(double value) => FromFloatingType(value);
        public static explicit operator Int144(decimal value) => FromDecimalType(value);
        public static explicit operator Int144(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int144(BigInteger value) => new Int144(value);

        // Sibling Types -> This Type
        public static implicit operator Int144(Int24 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int40 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int48 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int56 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int72 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int80 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int88 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int96 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int104 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int112 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int120 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int128 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(Int136 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int152 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int160 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int168 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int176 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int184 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int192 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int200 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int208 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int216 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int224 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int232 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int240 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(Int248 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt24 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt40 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt48 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt56 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt72 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt80 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt88 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt96 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt104 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt112 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt120 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt128 value) => new Int144(value.ToBigInteger());
        public static implicit operator Int144(UInt136 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt144 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt152 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt160 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt168 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt176 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt184 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt192 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt200 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt208 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt216 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt224 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt232 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt240 value) => new Int144(value.ToBigInteger());
        public static explicit operator Int144(UInt248 value) => new Int144(value.ToBigInteger());

        public static Int144 DivRem(Int144 dividend, Int144 divisor, out Int144 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int144(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int144(remainderBigInt);
            return result;
        }

        public static Int144 Pow(Int144 value, int exponent) => new Int144(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int144 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int144 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int144)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int144)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int144)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int144)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int144)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int144)})");
            }

            return new Int144(bigInt);
        }

        static Int144 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int144)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int144)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int144)})");
            }

            return new Int144(bigInt);
        }

        public static Int144 Parse(string value, IFormatProvider provider) => new Int144(BigInteger.Parse("0" + value, provider));
        public static Int144 Parse(string value, NumberStyles style) => new Int144(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int144 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int144(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int144 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int144 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int144)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int144(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int144 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int144 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int144)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int144(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int144 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int144 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int144 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int144))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int144)}");
            }

            // Compare the underlying object
            return CompareTo((Int144)obj);
        }

        public bool Equals(Int144 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int144 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int144)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int144 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int144>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int144 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int144)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int144>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int144 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int152 : IIntegerBase, IComparable, IComparable<Int152>, IEquatable<Int152>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 19;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int152 MaxValue = new Int152(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int152 MinValue = new Int152(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int152 Zero = new Int152(0);
        public static readonly Int152 One = new Int152(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int152(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int152(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int152 left, Int152 right) => !(left == right);
        public static bool operator ==(Int152 left, Int152 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int152 left, Int152 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int152 left, Int152 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int152 left, Int152 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int152 left, Int152 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int152 operator %(Int152 dividend, Int152 divisor) => new Int152(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int152 operator +(Int152 left, Int152 right) => new Int152(left.ToBigInteger() + right.ToBigInteger());
        public static Int152 operator -(Int152 left, Int152 right) => new Int152(left.ToBigInteger() - right.ToBigInteger());
        public static Int152 operator *(Int152 left, Int152 right) => new Int152(left.ToBigInteger() * right.ToBigInteger());
        public static Int152 operator /(Int152 dividend, Int152 divisor) => new Int152(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int152 operator >>(Int152 value, int shift) => new Int152(value.ToBigInteger() >> shift);
        public static Int152 operator <<(Int152 value, int shift) => new Int152(value.ToBigInteger() << shift);
        public static Int152 operator |(Int152 left, Int152 right) => new Int152(left.ToBigInteger() | right.ToBigInteger());
        public static Int152 operator &(Int152 left, Int152 right) => new Int152(left.ToBigInteger() & right.ToBigInteger());
        public static Int152 operator ^(Int152 left, Int152 right) => new Int152(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int152 operator ++(Int152 value) => value + One;
        public static Int152 operator --(Int152 value) => value - One;
        public static Int152 operator ~(Int152 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int152(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int152 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int152 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int152 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int152 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int152 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int152 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int152 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int152 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int152 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int152 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int152 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int152 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int152(sbyte value) => new Int152(value);
        public static implicit operator Int152(byte value) => new Int152(value);
        public static implicit operator Int152(short value) => new Int152(value);
        public static implicit operator Int152(ushort value) => new Int152(value);
        public static implicit operator Int152(int value) => new Int152(value);
        public static implicit operator Int152(uint value) => new Int152(value);
        public static implicit operator Int152(long value) => new Int152(value);
        public static implicit operator Int152(ulong value) => new Int152(value);
        public static explicit operator Int152(float value) => FromFloatingType(value);
        public static explicit operator Int152(double value) => FromFloatingType(value);
        public static explicit operator Int152(decimal value) => FromDecimalType(value);
        public static explicit operator Int152(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int152(BigInteger value) => new Int152(value);

        // Sibling Types -> This Type
        public static implicit operator Int152(Int24 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int40 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int48 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int56 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int72 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int80 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int88 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int96 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int104 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int112 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int120 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int128 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int136 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(Int144 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int160 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int168 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int176 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int184 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int192 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int200 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int208 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int216 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int224 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int232 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int240 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(Int248 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt24 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt40 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt48 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt56 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt72 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt80 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt88 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt96 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt104 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt112 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt120 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt128 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt136 value) => new Int152(value.ToBigInteger());
        public static implicit operator Int152(UInt144 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt152 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt160 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt168 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt176 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt184 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt192 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt200 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt208 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt216 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt224 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt232 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt240 value) => new Int152(value.ToBigInteger());
        public static explicit operator Int152(UInt248 value) => new Int152(value.ToBigInteger());

        public static Int152 DivRem(Int152 dividend, Int152 divisor, out Int152 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int152(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int152(remainderBigInt);
            return result;
        }

        public static Int152 Pow(Int152 value, int exponent) => new Int152(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int152 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int152 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int152)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int152)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int152)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int152)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int152)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int152)})");
            }

            return new Int152(bigInt);
        }

        static Int152 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int152)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int152)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int152)})");
            }

            return new Int152(bigInt);
        }

        public static Int152 Parse(string value, IFormatProvider provider) => new Int152(BigInteger.Parse("0" + value, provider));
        public static Int152 Parse(string value, NumberStyles style) => new Int152(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int152 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int152(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int152 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int152 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int152)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int152(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int152 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int152 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int152)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int152(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int152 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int152 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int152 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int152))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int152)}");
            }

            // Compare the underlying object
            return CompareTo((Int152)obj);
        }

        public bool Equals(Int152 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int152 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int152)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int152 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int152>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int152 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int152)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int152>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int152 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int160 : IIntegerBase, IComparable, IComparable<Int160>, IEquatable<Int160>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 20;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int160 MaxValue = new Int160(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int160 MinValue = new Int160(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int160 Zero = new Int160(0);
        public static readonly Int160 One = new Int160(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int160(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int160(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int160 left, Int160 right) => !(left == right);
        public static bool operator ==(Int160 left, Int160 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int160 left, Int160 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int160 left, Int160 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int160 left, Int160 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int160 left, Int160 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int160 operator %(Int160 dividend, Int160 divisor) => new Int160(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int160 operator +(Int160 left, Int160 right) => new Int160(left.ToBigInteger() + right.ToBigInteger());
        public static Int160 operator -(Int160 left, Int160 right) => new Int160(left.ToBigInteger() - right.ToBigInteger());
        public static Int160 operator *(Int160 left, Int160 right) => new Int160(left.ToBigInteger() * right.ToBigInteger());
        public static Int160 operator /(Int160 dividend, Int160 divisor) => new Int160(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int160 operator >>(Int160 value, int shift) => new Int160(value.ToBigInteger() >> shift);
        public static Int160 operator <<(Int160 value, int shift) => new Int160(value.ToBigInteger() << shift);
        public static Int160 operator |(Int160 left, Int160 right) => new Int160(left.ToBigInteger() | right.ToBigInteger());
        public static Int160 operator &(Int160 left, Int160 right) => new Int160(left.ToBigInteger() & right.ToBigInteger());
        public static Int160 operator ^(Int160 left, Int160 right) => new Int160(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int160 operator ++(Int160 value) => value + One;
        public static Int160 operator --(Int160 value) => value - One;
        public static Int160 operator ~(Int160 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int160(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int160 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int160 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int160 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int160 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int160 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int160 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int160 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int160 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int160 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int160 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int160 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int160 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int160(sbyte value) => new Int160(value);
        public static implicit operator Int160(byte value) => new Int160(value);
        public static implicit operator Int160(short value) => new Int160(value);
        public static implicit operator Int160(ushort value) => new Int160(value);
        public static implicit operator Int160(int value) => new Int160(value);
        public static implicit operator Int160(uint value) => new Int160(value);
        public static implicit operator Int160(long value) => new Int160(value);
        public static implicit operator Int160(ulong value) => new Int160(value);
        public static explicit operator Int160(float value) => FromFloatingType(value);
        public static explicit operator Int160(double value) => FromFloatingType(value);
        public static explicit operator Int160(decimal value) => FromDecimalType(value);
        public static explicit operator Int160(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int160(BigInteger value) => new Int160(value);

        // Sibling Types -> This Type
        public static implicit operator Int160(Int24 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int40 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int48 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int56 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int72 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int80 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int88 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int96 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int104 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int112 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int120 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int128 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int136 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int144 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(Int152 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int168 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int176 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int184 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int192 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int200 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int208 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int216 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int224 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int232 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int240 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(Int248 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt24 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt40 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt48 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt56 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt72 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt80 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt88 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt96 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt104 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt112 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt120 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt128 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt136 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt144 value) => new Int160(value.ToBigInteger());
        public static implicit operator Int160(UInt152 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt160 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt168 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt176 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt184 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt192 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt200 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt208 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt216 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt224 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt232 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt240 value) => new Int160(value.ToBigInteger());
        public static explicit operator Int160(UInt248 value) => new Int160(value.ToBigInteger());

        public static Int160 DivRem(Int160 dividend, Int160 divisor, out Int160 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int160(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int160(remainderBigInt);
            return result;
        }

        public static Int160 Pow(Int160 value, int exponent) => new Int160(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int160 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int160 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int160)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int160)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int160)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int160)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int160)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int160)})");
            }

            return new Int160(bigInt);
        }

        static Int160 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int160)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int160)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int160)})");
            }

            return new Int160(bigInt);
        }

        public static Int160 Parse(string value, IFormatProvider provider) => new Int160(BigInteger.Parse("0" + value, provider));
        public static Int160 Parse(string value, NumberStyles style) => new Int160(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int160 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int160(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int160 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int160 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int160)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int160(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int160 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int160 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int160)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int160(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int160 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int160 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int160 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int160))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int160)}");
            }

            // Compare the underlying object
            return CompareTo((Int160)obj);
        }

        public bool Equals(Int160 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int160 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int160)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int160 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int160>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int160 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int160)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int160>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int160 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int168 : IIntegerBase, IComparable, IComparable<Int168>, IEquatable<Int168>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 21;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int168 MaxValue = new Int168(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int168 MinValue = new Int168(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int168 Zero = new Int168(0);
        public static readonly Int168 One = new Int168(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int168(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int168(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int168 left, Int168 right) => !(left == right);
        public static bool operator ==(Int168 left, Int168 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int168 left, Int168 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int168 left, Int168 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int168 left, Int168 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int168 left, Int168 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int168 operator %(Int168 dividend, Int168 divisor) => new Int168(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int168 operator +(Int168 left, Int168 right) => new Int168(left.ToBigInteger() + right.ToBigInteger());
        public static Int168 operator -(Int168 left, Int168 right) => new Int168(left.ToBigInteger() - right.ToBigInteger());
        public static Int168 operator *(Int168 left, Int168 right) => new Int168(left.ToBigInteger() * right.ToBigInteger());
        public static Int168 operator /(Int168 dividend, Int168 divisor) => new Int168(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int168 operator >>(Int168 value, int shift) => new Int168(value.ToBigInteger() >> shift);
        public static Int168 operator <<(Int168 value, int shift) => new Int168(value.ToBigInteger() << shift);
        public static Int168 operator |(Int168 left, Int168 right) => new Int168(left.ToBigInteger() | right.ToBigInteger());
        public static Int168 operator &(Int168 left, Int168 right) => new Int168(left.ToBigInteger() & right.ToBigInteger());
        public static Int168 operator ^(Int168 left, Int168 right) => new Int168(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int168 operator ++(Int168 value) => value + One;
        public static Int168 operator --(Int168 value) => value - One;
        public static Int168 operator ~(Int168 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int168(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int168 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int168 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int168 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int168 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int168 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int168 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int168 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int168 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int168 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int168 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int168 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int168 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int168(sbyte value) => new Int168(value);
        public static implicit operator Int168(byte value) => new Int168(value);
        public static implicit operator Int168(short value) => new Int168(value);
        public static implicit operator Int168(ushort value) => new Int168(value);
        public static implicit operator Int168(int value) => new Int168(value);
        public static implicit operator Int168(uint value) => new Int168(value);
        public static implicit operator Int168(long value) => new Int168(value);
        public static implicit operator Int168(ulong value) => new Int168(value);
        public static explicit operator Int168(float value) => FromFloatingType(value);
        public static explicit operator Int168(double value) => FromFloatingType(value);
        public static explicit operator Int168(decimal value) => FromDecimalType(value);
        public static explicit operator Int168(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int168(BigInteger value) => new Int168(value);

        // Sibling Types -> This Type
        public static implicit operator Int168(Int24 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int40 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int48 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int56 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int72 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int80 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int88 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int96 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int104 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int112 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int120 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int128 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int136 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int144 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int152 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(Int160 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(Int176 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(Int184 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(Int192 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(Int200 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(Int208 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(Int216 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(Int224 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(Int232 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(Int240 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(Int248 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt24 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt40 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt48 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt56 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt72 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt80 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt88 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt96 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt104 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt112 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt120 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt128 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt136 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt144 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt152 value) => new Int168(value.ToBigInteger());
        public static implicit operator Int168(UInt160 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt168 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt176 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt184 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt192 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt200 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt208 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt216 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt224 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt232 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt240 value) => new Int168(value.ToBigInteger());
        public static explicit operator Int168(UInt248 value) => new Int168(value.ToBigInteger());

        public static Int168 DivRem(Int168 dividend, Int168 divisor, out Int168 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int168(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int168(remainderBigInt);
            return result;
        }

        public static Int168 Pow(Int168 value, int exponent) => new Int168(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int168 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int168 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int168)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int168)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int168)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int168)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int168)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int168)})");
            }

            return new Int168(bigInt);
        }

        static Int168 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int168)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int168)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int168)})");
            }

            return new Int168(bigInt);
        }

        public static Int168 Parse(string value, IFormatProvider provider) => new Int168(BigInteger.Parse("0" + value, provider));
        public static Int168 Parse(string value, NumberStyles style) => new Int168(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int168 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int168(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int168 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int168 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int168)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int168(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int168 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int168 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int168)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int168(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int168 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int168 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int168 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int168))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int168)}");
            }

            // Compare the underlying object
            return CompareTo((Int168)obj);
        }

        public bool Equals(Int168 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int168 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int168)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int168 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int168>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int168 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int168)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int168>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int168 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int176 : IIntegerBase, IComparable, IComparable<Int176>, IEquatable<Int176>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 22;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int176 MaxValue = new Int176(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int176 MinValue = new Int176(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int176 Zero = new Int176(0);
        public static readonly Int176 One = new Int176(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int176(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int176(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int176 left, Int176 right) => !(left == right);
        public static bool operator ==(Int176 left, Int176 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int176 left, Int176 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int176 left, Int176 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int176 left, Int176 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int176 left, Int176 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int176 operator %(Int176 dividend, Int176 divisor) => new Int176(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int176 operator +(Int176 left, Int176 right) => new Int176(left.ToBigInteger() + right.ToBigInteger());
        public static Int176 operator -(Int176 left, Int176 right) => new Int176(left.ToBigInteger() - right.ToBigInteger());
        public static Int176 operator *(Int176 left, Int176 right) => new Int176(left.ToBigInteger() * right.ToBigInteger());
        public static Int176 operator /(Int176 dividend, Int176 divisor) => new Int176(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int176 operator >>(Int176 value, int shift) => new Int176(value.ToBigInteger() >> shift);
        public static Int176 operator <<(Int176 value, int shift) => new Int176(value.ToBigInteger() << shift);
        public static Int176 operator |(Int176 left, Int176 right) => new Int176(left.ToBigInteger() | right.ToBigInteger());
        public static Int176 operator &(Int176 left, Int176 right) => new Int176(left.ToBigInteger() & right.ToBigInteger());
        public static Int176 operator ^(Int176 left, Int176 right) => new Int176(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int176 operator ++(Int176 value) => value + One;
        public static Int176 operator --(Int176 value) => value - One;
        public static Int176 operator ~(Int176 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int176(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int176 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int176 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int176 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int176 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int176 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int176 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int176 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int176 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int176 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int176 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int176 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int176 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int176(sbyte value) => new Int176(value);
        public static implicit operator Int176(byte value) => new Int176(value);
        public static implicit operator Int176(short value) => new Int176(value);
        public static implicit operator Int176(ushort value) => new Int176(value);
        public static implicit operator Int176(int value) => new Int176(value);
        public static implicit operator Int176(uint value) => new Int176(value);
        public static implicit operator Int176(long value) => new Int176(value);
        public static implicit operator Int176(ulong value) => new Int176(value);
        public static explicit operator Int176(float value) => FromFloatingType(value);
        public static explicit operator Int176(double value) => FromFloatingType(value);
        public static explicit operator Int176(decimal value) => FromDecimalType(value);
        public static explicit operator Int176(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int176(BigInteger value) => new Int176(value);

        // Sibling Types -> This Type
        public static implicit operator Int176(Int24 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int40 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int48 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int56 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int72 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int80 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int88 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int96 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int104 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int112 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int120 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int128 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int136 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int144 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int152 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int160 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(Int168 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(Int184 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(Int192 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(Int200 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(Int208 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(Int216 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(Int224 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(Int232 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(Int240 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(Int248 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt24 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt40 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt48 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt56 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt72 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt80 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt88 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt96 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt104 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt112 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt120 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt128 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt136 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt144 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt152 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt160 value) => new Int176(value.ToBigInteger());
        public static implicit operator Int176(UInt168 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(UInt176 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(UInt184 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(UInt192 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(UInt200 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(UInt208 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(UInt216 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(UInt224 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(UInt232 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(UInt240 value) => new Int176(value.ToBigInteger());
        public static explicit operator Int176(UInt248 value) => new Int176(value.ToBigInteger());

        public static Int176 DivRem(Int176 dividend, Int176 divisor, out Int176 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int176(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int176(remainderBigInt);
            return result;
        }

        public static Int176 Pow(Int176 value, int exponent) => new Int176(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int176 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int176 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int176)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int176)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int176)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int176)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int176)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int176)})");
            }

            return new Int176(bigInt);
        }

        static Int176 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int176)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int176)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int176)})");
            }

            return new Int176(bigInt);
        }

        public static Int176 Parse(string value, IFormatProvider provider) => new Int176(BigInteger.Parse("0" + value, provider));
        public static Int176 Parse(string value, NumberStyles style) => new Int176(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int176 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int176(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int176 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int176 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int176)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int176(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int176 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int176 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int176)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int176(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int176 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int176 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int176 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int176))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int176)}");
            }

            // Compare the underlying object
            return CompareTo((Int176)obj);
        }

        public bool Equals(Int176 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int176 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int176)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int176 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int176>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int176 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int176)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int176>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int176 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int184 : IIntegerBase, IComparable, IComparable<Int184>, IEquatable<Int184>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 23;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int184 MaxValue = new Int184(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int184 MinValue = new Int184(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int184 Zero = new Int184(0);
        public static readonly Int184 One = new Int184(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int184(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int184(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int184 left, Int184 right) => !(left == right);
        public static bool operator ==(Int184 left, Int184 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int184 left, Int184 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int184 left, Int184 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int184 left, Int184 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int184 left, Int184 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int184 operator %(Int184 dividend, Int184 divisor) => new Int184(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int184 operator +(Int184 left, Int184 right) => new Int184(left.ToBigInteger() + right.ToBigInteger());
        public static Int184 operator -(Int184 left, Int184 right) => new Int184(left.ToBigInteger() - right.ToBigInteger());
        public static Int184 operator *(Int184 left, Int184 right) => new Int184(left.ToBigInteger() * right.ToBigInteger());
        public static Int184 operator /(Int184 dividend, Int184 divisor) => new Int184(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int184 operator >>(Int184 value, int shift) => new Int184(value.ToBigInteger() >> shift);
        public static Int184 operator <<(Int184 value, int shift) => new Int184(value.ToBigInteger() << shift);
        public static Int184 operator |(Int184 left, Int184 right) => new Int184(left.ToBigInteger() | right.ToBigInteger());
        public static Int184 operator &(Int184 left, Int184 right) => new Int184(left.ToBigInteger() & right.ToBigInteger());
        public static Int184 operator ^(Int184 left, Int184 right) => new Int184(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int184 operator ++(Int184 value) => value + One;
        public static Int184 operator --(Int184 value) => value - One;
        public static Int184 operator ~(Int184 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int184(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int184 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int184 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int184 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int184 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int184 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int184 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int184 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int184 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int184 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int184 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int184 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int184 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int184(sbyte value) => new Int184(value);
        public static implicit operator Int184(byte value) => new Int184(value);
        public static implicit operator Int184(short value) => new Int184(value);
        public static implicit operator Int184(ushort value) => new Int184(value);
        public static implicit operator Int184(int value) => new Int184(value);
        public static implicit operator Int184(uint value) => new Int184(value);
        public static implicit operator Int184(long value) => new Int184(value);
        public static implicit operator Int184(ulong value) => new Int184(value);
        public static explicit operator Int184(float value) => FromFloatingType(value);
        public static explicit operator Int184(double value) => FromFloatingType(value);
        public static explicit operator Int184(decimal value) => FromDecimalType(value);
        public static explicit operator Int184(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int184(BigInteger value) => new Int184(value);

        // Sibling Types -> This Type
        public static implicit operator Int184(Int24 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int40 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int48 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int56 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int72 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int80 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int88 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int96 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int104 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int112 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int120 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int128 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int136 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int144 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int152 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int160 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int168 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(Int176 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(Int192 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(Int200 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(Int208 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(Int216 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(Int224 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(Int232 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(Int240 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(Int248 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt24 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt40 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt48 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt56 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt72 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt80 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt88 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt96 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt104 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt112 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt120 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt128 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt136 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt144 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt152 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt160 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt168 value) => new Int184(value.ToBigInteger());
        public static implicit operator Int184(UInt176 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(UInt184 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(UInt192 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(UInt200 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(UInt208 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(UInt216 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(UInt224 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(UInt232 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(UInt240 value) => new Int184(value.ToBigInteger());
        public static explicit operator Int184(UInt248 value) => new Int184(value.ToBigInteger());

        public static Int184 DivRem(Int184 dividend, Int184 divisor, out Int184 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int184(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int184(remainderBigInt);
            return result;
        }

        public static Int184 Pow(Int184 value, int exponent) => new Int184(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int184 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int184 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int184)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int184)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int184)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int184)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int184)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int184)})");
            }

            return new Int184(bigInt);
        }

        static Int184 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int184)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int184)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int184)})");
            }

            return new Int184(bigInt);
        }

        public static Int184 Parse(string value, IFormatProvider provider) => new Int184(BigInteger.Parse("0" + value, provider));
        public static Int184 Parse(string value, NumberStyles style) => new Int184(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int184 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int184(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int184 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int184 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int184)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int184(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int184 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int184 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int184)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int184(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int184 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int184 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int184 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int184))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int184)}");
            }

            // Compare the underlying object
            return CompareTo((Int184)obj);
        }

        public bool Equals(Int184 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int184 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int184)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int184 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int184>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int184 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int184)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int184>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int184 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int192 : IIntegerBase, IComparable, IComparable<Int192>, IEquatable<Int192>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 24;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int192 MaxValue = new Int192(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int192 MinValue = new Int192(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int192 Zero = new Int192(0);
        public static readonly Int192 One = new Int192(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int192(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int192(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int192 left, Int192 right) => !(left == right);
        public static bool operator ==(Int192 left, Int192 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int192 left, Int192 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int192 left, Int192 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int192 left, Int192 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int192 left, Int192 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int192 operator %(Int192 dividend, Int192 divisor) => new Int192(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int192 operator +(Int192 left, Int192 right) => new Int192(left.ToBigInteger() + right.ToBigInteger());
        public static Int192 operator -(Int192 left, Int192 right) => new Int192(left.ToBigInteger() - right.ToBigInteger());
        public static Int192 operator *(Int192 left, Int192 right) => new Int192(left.ToBigInteger() * right.ToBigInteger());
        public static Int192 operator /(Int192 dividend, Int192 divisor) => new Int192(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int192 operator >>(Int192 value, int shift) => new Int192(value.ToBigInteger() >> shift);
        public static Int192 operator <<(Int192 value, int shift) => new Int192(value.ToBigInteger() << shift);
        public static Int192 operator |(Int192 left, Int192 right) => new Int192(left.ToBigInteger() | right.ToBigInteger());
        public static Int192 operator &(Int192 left, Int192 right) => new Int192(left.ToBigInteger() & right.ToBigInteger());
        public static Int192 operator ^(Int192 left, Int192 right) => new Int192(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int192 operator ++(Int192 value) => value + One;
        public static Int192 operator --(Int192 value) => value - One;
        public static Int192 operator ~(Int192 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int192(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int192 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int192 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int192 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int192 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int192 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int192 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int192 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int192 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int192 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int192 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int192 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int192 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int192(sbyte value) => new Int192(value);
        public static implicit operator Int192(byte value) => new Int192(value);
        public static implicit operator Int192(short value) => new Int192(value);
        public static implicit operator Int192(ushort value) => new Int192(value);
        public static implicit operator Int192(int value) => new Int192(value);
        public static implicit operator Int192(uint value) => new Int192(value);
        public static implicit operator Int192(long value) => new Int192(value);
        public static implicit operator Int192(ulong value) => new Int192(value);
        public static explicit operator Int192(float value) => FromFloatingType(value);
        public static explicit operator Int192(double value) => FromFloatingType(value);
        public static explicit operator Int192(decimal value) => FromDecimalType(value);
        public static explicit operator Int192(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int192(BigInteger value) => new Int192(value);

        // Sibling Types -> This Type
        public static implicit operator Int192(Int24 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int40 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int48 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int56 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int72 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int80 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int88 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int96 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int104 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int112 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int120 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int128 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int136 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int144 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int152 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int160 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int168 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int176 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(Int184 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(Int200 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(Int208 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(Int216 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(Int224 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(Int232 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(Int240 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(Int248 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt24 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt40 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt48 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt56 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt72 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt80 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt88 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt96 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt104 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt112 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt120 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt128 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt136 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt144 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt152 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt160 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt168 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt176 value) => new Int192(value.ToBigInteger());
        public static implicit operator Int192(UInt184 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(UInt192 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(UInt200 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(UInt208 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(UInt216 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(UInt224 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(UInt232 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(UInt240 value) => new Int192(value.ToBigInteger());
        public static explicit operator Int192(UInt248 value) => new Int192(value.ToBigInteger());

        public static Int192 DivRem(Int192 dividend, Int192 divisor, out Int192 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int192(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int192(remainderBigInt);
            return result;
        }

        public static Int192 Pow(Int192 value, int exponent) => new Int192(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int192 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int192 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int192)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int192)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int192)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int192)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int192)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int192)})");
            }

            return new Int192(bigInt);
        }

        static Int192 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int192)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int192)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int192)})");
            }

            return new Int192(bigInt);
        }

        public static Int192 Parse(string value, IFormatProvider provider) => new Int192(BigInteger.Parse("0" + value, provider));
        public static Int192 Parse(string value, NumberStyles style) => new Int192(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int192 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int192(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int192 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int192 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int192)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int192(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int192 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int192 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int192)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int192(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int192 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int192 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int192 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int192))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int192)}");
            }

            // Compare the underlying object
            return CompareTo((Int192)obj);
        }

        public bool Equals(Int192 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int192 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int192)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int192 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int192>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int192 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int192)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int192>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int192 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int200 : IIntegerBase, IComparable, IComparable<Int200>, IEquatable<Int200>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 25;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int200 MaxValue = new Int200(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int200 MinValue = new Int200(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int200 Zero = new Int200(0);
        public static readonly Int200 One = new Int200(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int200(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int200(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int200 left, Int200 right) => !(left == right);
        public static bool operator ==(Int200 left, Int200 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int200 left, Int200 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int200 left, Int200 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int200 left, Int200 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int200 left, Int200 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int200 operator %(Int200 dividend, Int200 divisor) => new Int200(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int200 operator +(Int200 left, Int200 right) => new Int200(left.ToBigInteger() + right.ToBigInteger());
        public static Int200 operator -(Int200 left, Int200 right) => new Int200(left.ToBigInteger() - right.ToBigInteger());
        public static Int200 operator *(Int200 left, Int200 right) => new Int200(left.ToBigInteger() * right.ToBigInteger());
        public static Int200 operator /(Int200 dividend, Int200 divisor) => new Int200(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int200 operator >>(Int200 value, int shift) => new Int200(value.ToBigInteger() >> shift);
        public static Int200 operator <<(Int200 value, int shift) => new Int200(value.ToBigInteger() << shift);
        public static Int200 operator |(Int200 left, Int200 right) => new Int200(left.ToBigInteger() | right.ToBigInteger());
        public static Int200 operator &(Int200 left, Int200 right) => new Int200(left.ToBigInteger() & right.ToBigInteger());
        public static Int200 operator ^(Int200 left, Int200 right) => new Int200(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int200 operator ++(Int200 value) => value + One;
        public static Int200 operator --(Int200 value) => value - One;
        public static Int200 operator ~(Int200 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int200(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int200 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int200 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int200 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int200 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int200 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int200 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int200 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int200 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int200 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int200 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int200 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int200 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int200(sbyte value) => new Int200(value);
        public static implicit operator Int200(byte value) => new Int200(value);
        public static implicit operator Int200(short value) => new Int200(value);
        public static implicit operator Int200(ushort value) => new Int200(value);
        public static implicit operator Int200(int value) => new Int200(value);
        public static implicit operator Int200(uint value) => new Int200(value);
        public static implicit operator Int200(long value) => new Int200(value);
        public static implicit operator Int200(ulong value) => new Int200(value);
        public static explicit operator Int200(float value) => FromFloatingType(value);
        public static explicit operator Int200(double value) => FromFloatingType(value);
        public static explicit operator Int200(decimal value) => FromDecimalType(value);
        public static explicit operator Int200(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int200(BigInteger value) => new Int200(value);

        // Sibling Types -> This Type
        public static implicit operator Int200(Int24 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int40 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int48 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int56 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int72 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int80 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int88 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int96 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int104 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int112 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int120 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int128 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int136 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int144 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int152 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int160 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int168 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int176 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int184 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(Int192 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(Int208 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(Int216 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(Int224 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(Int232 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(Int240 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(Int248 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt24 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt40 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt48 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt56 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt72 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt80 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt88 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt96 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt104 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt112 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt120 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt128 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt136 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt144 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt152 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt160 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt168 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt176 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt184 value) => new Int200(value.ToBigInteger());
        public static implicit operator Int200(UInt192 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(UInt200 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(UInt208 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(UInt216 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(UInt224 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(UInt232 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(UInt240 value) => new Int200(value.ToBigInteger());
        public static explicit operator Int200(UInt248 value) => new Int200(value.ToBigInteger());

        public static Int200 DivRem(Int200 dividend, Int200 divisor, out Int200 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int200(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int200(remainderBigInt);
            return result;
        }

        public static Int200 Pow(Int200 value, int exponent) => new Int200(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int200 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int200 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int200)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int200)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int200)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int200)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int200)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int200)})");
            }

            return new Int200(bigInt);
        }

        static Int200 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int200)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int200)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int200)})");
            }

            return new Int200(bigInt);
        }

        public static Int200 Parse(string value, IFormatProvider provider) => new Int200(BigInteger.Parse("0" + value, provider));
        public static Int200 Parse(string value, NumberStyles style) => new Int200(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int200 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int200(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int200 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int200 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int200)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int200(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int200 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int200 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int200)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int200(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int200 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int200 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int200 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int200))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int200)}");
            }

            // Compare the underlying object
            return CompareTo((Int200)obj);
        }

        public bool Equals(Int200 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int200 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int200)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int200 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int200>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int200 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int200)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int200>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int200 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int208 : IIntegerBase, IComparable, IComparable<Int208>, IEquatable<Int208>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 26;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int208 MaxValue = new Int208(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int208 MinValue = new Int208(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int208 Zero = new Int208(0);
        public static readonly Int208 One = new Int208(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int208(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int208(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int208 left, Int208 right) => !(left == right);
        public static bool operator ==(Int208 left, Int208 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int208 left, Int208 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int208 left, Int208 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int208 left, Int208 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int208 left, Int208 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int208 operator %(Int208 dividend, Int208 divisor) => new Int208(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int208 operator +(Int208 left, Int208 right) => new Int208(left.ToBigInteger() + right.ToBigInteger());
        public static Int208 operator -(Int208 left, Int208 right) => new Int208(left.ToBigInteger() - right.ToBigInteger());
        public static Int208 operator *(Int208 left, Int208 right) => new Int208(left.ToBigInteger() * right.ToBigInteger());
        public static Int208 operator /(Int208 dividend, Int208 divisor) => new Int208(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int208 operator >>(Int208 value, int shift) => new Int208(value.ToBigInteger() >> shift);
        public static Int208 operator <<(Int208 value, int shift) => new Int208(value.ToBigInteger() << shift);
        public static Int208 operator |(Int208 left, Int208 right) => new Int208(left.ToBigInteger() | right.ToBigInteger());
        public static Int208 operator &(Int208 left, Int208 right) => new Int208(left.ToBigInteger() & right.ToBigInteger());
        public static Int208 operator ^(Int208 left, Int208 right) => new Int208(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int208 operator ++(Int208 value) => value + One;
        public static Int208 operator --(Int208 value) => value - One;
        public static Int208 operator ~(Int208 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int208(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int208 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int208 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int208 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int208 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int208 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int208 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int208 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int208 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int208 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int208 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int208 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int208 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int208(sbyte value) => new Int208(value);
        public static implicit operator Int208(byte value) => new Int208(value);
        public static implicit operator Int208(short value) => new Int208(value);
        public static implicit operator Int208(ushort value) => new Int208(value);
        public static implicit operator Int208(int value) => new Int208(value);
        public static implicit operator Int208(uint value) => new Int208(value);
        public static implicit operator Int208(long value) => new Int208(value);
        public static implicit operator Int208(ulong value) => new Int208(value);
        public static explicit operator Int208(float value) => FromFloatingType(value);
        public static explicit operator Int208(double value) => FromFloatingType(value);
        public static explicit operator Int208(decimal value) => FromDecimalType(value);
        public static explicit operator Int208(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int208(BigInteger value) => new Int208(value);

        // Sibling Types -> This Type
        public static implicit operator Int208(Int24 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int40 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int48 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int56 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int72 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int80 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int88 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int96 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int104 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int112 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int120 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int128 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int136 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int144 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int152 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int160 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int168 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int176 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int184 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int192 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(Int200 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(Int216 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(Int224 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(Int232 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(Int240 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(Int248 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt24 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt40 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt48 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt56 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt72 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt80 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt88 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt96 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt104 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt112 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt120 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt128 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt136 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt144 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt152 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt160 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt168 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt176 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt184 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt192 value) => new Int208(value.ToBigInteger());
        public static implicit operator Int208(UInt200 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(UInt208 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(UInt216 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(UInt224 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(UInt232 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(UInt240 value) => new Int208(value.ToBigInteger());
        public static explicit operator Int208(UInt248 value) => new Int208(value.ToBigInteger());

        public static Int208 DivRem(Int208 dividend, Int208 divisor, out Int208 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int208(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int208(remainderBigInt);
            return result;
        }

        public static Int208 Pow(Int208 value, int exponent) => new Int208(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int208 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int208 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int208)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int208)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int208)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int208)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int208)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int208)})");
            }

            return new Int208(bigInt);
        }

        static Int208 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int208)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int208)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int208)})");
            }

            return new Int208(bigInt);
        }

        public static Int208 Parse(string value, IFormatProvider provider) => new Int208(BigInteger.Parse("0" + value, provider));
        public static Int208 Parse(string value, NumberStyles style) => new Int208(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int208 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int208(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int208 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int208 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int208)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int208(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int208 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int208 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int208)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int208(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int208 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int208 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int208 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int208))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int208)}");
            }

            // Compare the underlying object
            return CompareTo((Int208)obj);
        }

        public bool Equals(Int208 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int208 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int208)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int208 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int208>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int208 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int208)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int208>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int208 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int216 : IIntegerBase, IComparable, IComparable<Int216>, IEquatable<Int216>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 27;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int216 MaxValue = new Int216(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int216 MinValue = new Int216(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int216 Zero = new Int216(0);
        public static readonly Int216 One = new Int216(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        private readonly byte _b26;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int216(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int216(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int216 left, Int216 right) => !(left == right);
        public static bool operator ==(Int216 left, Int216 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int216 left, Int216 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int216 left, Int216 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int216 left, Int216 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int216 left, Int216 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int216 operator %(Int216 dividend, Int216 divisor) => new Int216(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int216 operator +(Int216 left, Int216 right) => new Int216(left.ToBigInteger() + right.ToBigInteger());
        public static Int216 operator -(Int216 left, Int216 right) => new Int216(left.ToBigInteger() - right.ToBigInteger());
        public static Int216 operator *(Int216 left, Int216 right) => new Int216(left.ToBigInteger() * right.ToBigInteger());
        public static Int216 operator /(Int216 dividend, Int216 divisor) => new Int216(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int216 operator >>(Int216 value, int shift) => new Int216(value.ToBigInteger() >> shift);
        public static Int216 operator <<(Int216 value, int shift) => new Int216(value.ToBigInteger() << shift);
        public static Int216 operator |(Int216 left, Int216 right) => new Int216(left.ToBigInteger() | right.ToBigInteger());
        public static Int216 operator &(Int216 left, Int216 right) => new Int216(left.ToBigInteger() & right.ToBigInteger());
        public static Int216 operator ^(Int216 left, Int216 right) => new Int216(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int216 operator ++(Int216 value) => value + One;
        public static Int216 operator --(Int216 value) => value - One;
        public static Int216 operator ~(Int216 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int216(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int216 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int216 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int216 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int216 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int216 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int216 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int216 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int216 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int216 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int216 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int216 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int216 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int216(sbyte value) => new Int216(value);
        public static implicit operator Int216(byte value) => new Int216(value);
        public static implicit operator Int216(short value) => new Int216(value);
        public static implicit operator Int216(ushort value) => new Int216(value);
        public static implicit operator Int216(int value) => new Int216(value);
        public static implicit operator Int216(uint value) => new Int216(value);
        public static implicit operator Int216(long value) => new Int216(value);
        public static implicit operator Int216(ulong value) => new Int216(value);
        public static explicit operator Int216(float value) => FromFloatingType(value);
        public static explicit operator Int216(double value) => FromFloatingType(value);
        public static explicit operator Int216(decimal value) => FromDecimalType(value);
        public static explicit operator Int216(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int216(BigInteger value) => new Int216(value);

        // Sibling Types -> This Type
        public static implicit operator Int216(Int24 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int40 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int48 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int56 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int72 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int80 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int88 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int96 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int104 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int112 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int120 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int128 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int136 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int144 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int152 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int160 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int168 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int176 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int184 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int192 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int200 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(Int208 value) => new Int216(value.ToBigInteger());
        public static explicit operator Int216(Int224 value) => new Int216(value.ToBigInteger());
        public static explicit operator Int216(Int232 value) => new Int216(value.ToBigInteger());
        public static explicit operator Int216(Int240 value) => new Int216(value.ToBigInteger());
        public static explicit operator Int216(Int248 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt24 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt40 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt48 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt56 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt72 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt80 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt88 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt96 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt104 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt112 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt120 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt128 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt136 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt144 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt152 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt160 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt168 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt176 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt184 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt192 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt200 value) => new Int216(value.ToBigInteger());
        public static implicit operator Int216(UInt208 value) => new Int216(value.ToBigInteger());
        public static explicit operator Int216(UInt216 value) => new Int216(value.ToBigInteger());
        public static explicit operator Int216(UInt224 value) => new Int216(value.ToBigInteger());
        public static explicit operator Int216(UInt232 value) => new Int216(value.ToBigInteger());
        public static explicit operator Int216(UInt240 value) => new Int216(value.ToBigInteger());
        public static explicit operator Int216(UInt248 value) => new Int216(value.ToBigInteger());

        public static Int216 DivRem(Int216 dividend, Int216 divisor, out Int216 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int216(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int216(remainderBigInt);
            return result;
        }

        public static Int216 Pow(Int216 value, int exponent) => new Int216(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int216 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int216 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int216)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int216)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int216)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int216)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int216)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int216)})");
            }

            return new Int216(bigInt);
        }

        static Int216 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int216)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int216)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int216)})");
            }

            return new Int216(bigInt);
        }

        public static Int216 Parse(string value, IFormatProvider provider) => new Int216(BigInteger.Parse("0" + value, provider));
        public static Int216 Parse(string value, NumberStyles style) => new Int216(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int216 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int216(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int216 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int216 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int216)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int216(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int216 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int216 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int216)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int216(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int216 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int216 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int216 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int216))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int216)}");
            }

            // Compare the underlying object
            return CompareTo((Int216)obj);
        }

        public bool Equals(Int216 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int216 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int216)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25, _b26).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int216 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int216>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int216 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int216)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int216>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int216 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int224 : IIntegerBase, IComparable, IComparable<Int224>, IEquatable<Int224>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 28;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int224 MaxValue = new Int224(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int224 MinValue = new Int224(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int224 Zero = new Int224(0);
        public static readonly Int224 One = new Int224(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        private readonly byte _b26;
        private readonly byte _b27;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int224(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int224(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int224 left, Int224 right) => !(left == right);
        public static bool operator ==(Int224 left, Int224 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int224 left, Int224 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int224 left, Int224 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int224 left, Int224 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int224 left, Int224 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int224 operator %(Int224 dividend, Int224 divisor) => new Int224(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int224 operator +(Int224 left, Int224 right) => new Int224(left.ToBigInteger() + right.ToBigInteger());
        public static Int224 operator -(Int224 left, Int224 right) => new Int224(left.ToBigInteger() - right.ToBigInteger());
        public static Int224 operator *(Int224 left, Int224 right) => new Int224(left.ToBigInteger() * right.ToBigInteger());
        public static Int224 operator /(Int224 dividend, Int224 divisor) => new Int224(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int224 operator >>(Int224 value, int shift) => new Int224(value.ToBigInteger() >> shift);
        public static Int224 operator <<(Int224 value, int shift) => new Int224(value.ToBigInteger() << shift);
        public static Int224 operator |(Int224 left, Int224 right) => new Int224(left.ToBigInteger() | right.ToBigInteger());
        public static Int224 operator &(Int224 left, Int224 right) => new Int224(left.ToBigInteger() & right.ToBigInteger());
        public static Int224 operator ^(Int224 left, Int224 right) => new Int224(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int224 operator ++(Int224 value) => value + One;
        public static Int224 operator --(Int224 value) => value - One;
        public static Int224 operator ~(Int224 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int224(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int224 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int224 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int224 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int224 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int224 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int224 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int224 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int224 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int224 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int224 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int224 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int224 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int224(sbyte value) => new Int224(value);
        public static implicit operator Int224(byte value) => new Int224(value);
        public static implicit operator Int224(short value) => new Int224(value);
        public static implicit operator Int224(ushort value) => new Int224(value);
        public static implicit operator Int224(int value) => new Int224(value);
        public static implicit operator Int224(uint value) => new Int224(value);
        public static implicit operator Int224(long value) => new Int224(value);
        public static implicit operator Int224(ulong value) => new Int224(value);
        public static explicit operator Int224(float value) => FromFloatingType(value);
        public static explicit operator Int224(double value) => FromFloatingType(value);
        public static explicit operator Int224(decimal value) => FromDecimalType(value);
        public static explicit operator Int224(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int224(BigInteger value) => new Int224(value);

        // Sibling Types -> This Type
        public static implicit operator Int224(Int24 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int40 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int48 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int56 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int72 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int80 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int88 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int96 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int104 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int112 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int120 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int128 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int136 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int144 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int152 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int160 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int168 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int176 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int184 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int192 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int200 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int208 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(Int216 value) => new Int224(value.ToBigInteger());
        public static explicit operator Int224(Int232 value) => new Int224(value.ToBigInteger());
        public static explicit operator Int224(Int240 value) => new Int224(value.ToBigInteger());
        public static explicit operator Int224(Int248 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt24 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt40 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt48 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt56 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt72 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt80 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt88 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt96 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt104 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt112 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt120 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt128 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt136 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt144 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt152 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt160 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt168 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt176 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt184 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt192 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt200 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt208 value) => new Int224(value.ToBigInteger());
        public static implicit operator Int224(UInt216 value) => new Int224(value.ToBigInteger());
        public static explicit operator Int224(UInt224 value) => new Int224(value.ToBigInteger());
        public static explicit operator Int224(UInt232 value) => new Int224(value.ToBigInteger());
        public static explicit operator Int224(UInt240 value) => new Int224(value.ToBigInteger());
        public static explicit operator Int224(UInt248 value) => new Int224(value.ToBigInteger());

        public static Int224 DivRem(Int224 dividend, Int224 divisor, out Int224 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int224(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int224(remainderBigInt);
            return result;
        }

        public static Int224 Pow(Int224 value, int exponent) => new Int224(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int224 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int224 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int224)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int224)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int224)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int224)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int224)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int224)})");
            }

            return new Int224(bigInt);
        }

        static Int224 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int224)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int224)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int224)})");
            }

            return new Int224(bigInt);
        }

        public static Int224 Parse(string value, IFormatProvider provider) => new Int224(BigInteger.Parse("0" + value, provider));
        public static Int224 Parse(string value, NumberStyles style) => new Int224(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int224 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int224(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int224 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int224 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int224)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int224(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int224 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int224 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int224)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int224(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int224 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int224 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int224 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int224))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int224)}");
            }

            // Compare the underlying object
            return CompareTo((Int224)obj);
        }

        public bool Equals(Int224 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int224 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int224)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25, _b26, _b27).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int224 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int224>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int224 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int224)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int224>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int224 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int232 : IIntegerBase, IComparable, IComparable<Int232>, IEquatable<Int232>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 29;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int232 MaxValue = new Int232(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int232 MinValue = new Int232(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int232 Zero = new Int232(0);
        public static readonly Int232 One = new Int232(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        private readonly byte _b26;
        private readonly byte _b27;
        private readonly byte _b28;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int232(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int232(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int232 left, Int232 right) => !(left == right);
        public static bool operator ==(Int232 left, Int232 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int232 left, Int232 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int232 left, Int232 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int232 left, Int232 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int232 left, Int232 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int232 operator %(Int232 dividend, Int232 divisor) => new Int232(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int232 operator +(Int232 left, Int232 right) => new Int232(left.ToBigInteger() + right.ToBigInteger());
        public static Int232 operator -(Int232 left, Int232 right) => new Int232(left.ToBigInteger() - right.ToBigInteger());
        public static Int232 operator *(Int232 left, Int232 right) => new Int232(left.ToBigInteger() * right.ToBigInteger());
        public static Int232 operator /(Int232 dividend, Int232 divisor) => new Int232(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int232 operator >>(Int232 value, int shift) => new Int232(value.ToBigInteger() >> shift);
        public static Int232 operator <<(Int232 value, int shift) => new Int232(value.ToBigInteger() << shift);
        public static Int232 operator |(Int232 left, Int232 right) => new Int232(left.ToBigInteger() | right.ToBigInteger());
        public static Int232 operator &(Int232 left, Int232 right) => new Int232(left.ToBigInteger() & right.ToBigInteger());
        public static Int232 operator ^(Int232 left, Int232 right) => new Int232(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int232 operator ++(Int232 value) => value + One;
        public static Int232 operator --(Int232 value) => value - One;
        public static Int232 operator ~(Int232 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int232(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int232 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int232 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int232 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int232 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int232 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int232 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int232 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int232 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int232 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int232 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int232 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int232 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int232(sbyte value) => new Int232(value);
        public static implicit operator Int232(byte value) => new Int232(value);
        public static implicit operator Int232(short value) => new Int232(value);
        public static implicit operator Int232(ushort value) => new Int232(value);
        public static implicit operator Int232(int value) => new Int232(value);
        public static implicit operator Int232(uint value) => new Int232(value);
        public static implicit operator Int232(long value) => new Int232(value);
        public static implicit operator Int232(ulong value) => new Int232(value);
        public static explicit operator Int232(float value) => FromFloatingType(value);
        public static explicit operator Int232(double value) => FromFloatingType(value);
        public static explicit operator Int232(decimal value) => FromDecimalType(value);
        public static explicit operator Int232(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int232(BigInteger value) => new Int232(value);

        // Sibling Types -> This Type
        public static implicit operator Int232(Int24 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int40 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int48 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int56 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int72 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int80 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int88 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int96 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int104 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int112 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int120 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int128 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int136 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int144 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int152 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int160 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int168 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int176 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int184 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int192 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int200 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int208 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int216 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(Int224 value) => new Int232(value.ToBigInteger());
        public static explicit operator Int232(Int240 value) => new Int232(value.ToBigInteger());
        public static explicit operator Int232(Int248 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt24 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt40 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt48 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt56 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt72 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt80 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt88 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt96 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt104 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt112 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt120 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt128 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt136 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt144 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt152 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt160 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt168 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt176 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt184 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt192 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt200 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt208 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt216 value) => new Int232(value.ToBigInteger());
        public static implicit operator Int232(UInt224 value) => new Int232(value.ToBigInteger());
        public static explicit operator Int232(UInt232 value) => new Int232(value.ToBigInteger());
        public static explicit operator Int232(UInt240 value) => new Int232(value.ToBigInteger());
        public static explicit operator Int232(UInt248 value) => new Int232(value.ToBigInteger());

        public static Int232 DivRem(Int232 dividend, Int232 divisor, out Int232 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int232(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int232(remainderBigInt);
            return result;
        }

        public static Int232 Pow(Int232 value, int exponent) => new Int232(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int232 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int232 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int232)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int232)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int232)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int232)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int232)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int232)})");
            }

            return new Int232(bigInt);
        }

        static Int232 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int232)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int232)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int232)})");
            }

            return new Int232(bigInt);
        }

        public static Int232 Parse(string value, IFormatProvider provider) => new Int232(BigInteger.Parse("0" + value, provider));
        public static Int232 Parse(string value, NumberStyles style) => new Int232(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int232 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int232(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int232 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int232 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int232)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int232(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int232 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int232 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int232)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int232(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int232 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int232 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int232 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int232))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int232)}");
            }

            // Compare the underlying object
            return CompareTo((Int232)obj);
        }

        public bool Equals(Int232 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int232 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int232)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25, _b26, _b27, _b28).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int232 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int232>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int232 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int232)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int232>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int232 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int240 : IIntegerBase, IComparable, IComparable<Int240>, IEquatable<Int240>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 30;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int240 MaxValue = new Int240(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int240 MinValue = new Int240(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int240 Zero = new Int240(0);
        public static readonly Int240 One = new Int240(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        private readonly byte _b26;
        private readonly byte _b27;
        private readonly byte _b28;
        private readonly byte _b29;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int240(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int240(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int240 left, Int240 right) => !(left == right);
        public static bool operator ==(Int240 left, Int240 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int240 left, Int240 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int240 left, Int240 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int240 left, Int240 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int240 left, Int240 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int240 operator %(Int240 dividend, Int240 divisor) => new Int240(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int240 operator +(Int240 left, Int240 right) => new Int240(left.ToBigInteger() + right.ToBigInteger());
        public static Int240 operator -(Int240 left, Int240 right) => new Int240(left.ToBigInteger() - right.ToBigInteger());
        public static Int240 operator *(Int240 left, Int240 right) => new Int240(left.ToBigInteger() * right.ToBigInteger());
        public static Int240 operator /(Int240 dividend, Int240 divisor) => new Int240(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int240 operator >>(Int240 value, int shift) => new Int240(value.ToBigInteger() >> shift);
        public static Int240 operator <<(Int240 value, int shift) => new Int240(value.ToBigInteger() << shift);
        public static Int240 operator |(Int240 left, Int240 right) => new Int240(left.ToBigInteger() | right.ToBigInteger());
        public static Int240 operator &(Int240 left, Int240 right) => new Int240(left.ToBigInteger() & right.ToBigInteger());
        public static Int240 operator ^(Int240 left, Int240 right) => new Int240(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int240 operator ++(Int240 value) => value + One;
        public static Int240 operator --(Int240 value) => value - One;
        public static Int240 operator ~(Int240 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int240(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int240 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int240 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int240 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int240 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int240 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int240 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int240 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int240 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int240 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int240 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int240 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int240 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int240(sbyte value) => new Int240(value);
        public static implicit operator Int240(byte value) => new Int240(value);
        public static implicit operator Int240(short value) => new Int240(value);
        public static implicit operator Int240(ushort value) => new Int240(value);
        public static implicit operator Int240(int value) => new Int240(value);
        public static implicit operator Int240(uint value) => new Int240(value);
        public static implicit operator Int240(long value) => new Int240(value);
        public static implicit operator Int240(ulong value) => new Int240(value);
        public static explicit operator Int240(float value) => FromFloatingType(value);
        public static explicit operator Int240(double value) => FromFloatingType(value);
        public static explicit operator Int240(decimal value) => FromDecimalType(value);
        public static explicit operator Int240(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int240(BigInteger value) => new Int240(value);

        // Sibling Types -> This Type
        public static implicit operator Int240(Int24 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int40 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int48 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int56 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int72 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int80 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int88 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int96 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int104 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int112 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int120 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int128 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int136 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int144 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int152 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int160 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int168 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int176 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int184 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int192 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int200 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int208 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int216 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int224 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(Int232 value) => new Int240(value.ToBigInteger());
        public static explicit operator Int240(Int248 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt24 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt40 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt48 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt56 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt72 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt80 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt88 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt96 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt104 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt112 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt120 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt128 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt136 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt144 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt152 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt160 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt168 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt176 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt184 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt192 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt200 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt208 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt216 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt224 value) => new Int240(value.ToBigInteger());
        public static implicit operator Int240(UInt232 value) => new Int240(value.ToBigInteger());
        public static explicit operator Int240(UInt240 value) => new Int240(value.ToBigInteger());
        public static explicit operator Int240(UInt248 value) => new Int240(value.ToBigInteger());

        public static Int240 DivRem(Int240 dividend, Int240 divisor, out Int240 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int240(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int240(remainderBigInt);
            return result;
        }

        public static Int240 Pow(Int240 value, int exponent) => new Int240(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int240 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int240 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int240)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int240)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int240)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int240)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int240)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int240)})");
            }

            return new Int240(bigInt);
        }

        static Int240 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int240)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int240)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int240)})");
            }

            return new Int240(bigInt);
        }

        public static Int240 Parse(string value, IFormatProvider provider) => new Int240(BigInteger.Parse("0" + value, provider));
        public static Int240 Parse(string value, NumberStyles style) => new Int240(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int240 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int240(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int240 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int240 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int240)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int240(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int240 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int240 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int240)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int240(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int240 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int240 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int240 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int240))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int240)}");
            }

            // Compare the underlying object
            return CompareTo((Int240)obj);
        }

        public bool Equals(Int240 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int240 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int240)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25, _b26, _b27, _b28, _b29).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int240 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int240>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int240 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int240)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int240>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int240 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Int248 : IIntegerBase, IComparable, IComparable<Int248>, IEquatable<Int248>
    {
        #region Constants
        public const bool SIGNED = true;
        public const int SIZE = 31;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly Int248 MaxValue = new Int248(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly Int248 MinValue = new Int248(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly Int248 Zero = new Int248(0);
        public static readonly Int248 One = new Int248(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        private readonly byte _b26;
        private readonly byte _b27;
        private readonly byte _b28;
        private readonly byte _b29;
        private readonly byte _b30;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public Int248(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public Int248(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(Int248 left, Int248 right) => !(left == right);
        public static bool operator ==(Int248 left, Int248 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(Int248 left, Int248 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(Int248 left, Int248 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(Int248 left, Int248 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(Int248 left, Int248 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static Int248 operator %(Int248 dividend, Int248 divisor) => new Int248(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static Int248 operator +(Int248 left, Int248 right) => new Int248(left.ToBigInteger() + right.ToBigInteger());
        public static Int248 operator -(Int248 left, Int248 right) => new Int248(left.ToBigInteger() - right.ToBigInteger());
        public static Int248 operator *(Int248 left, Int248 right) => new Int248(left.ToBigInteger() * right.ToBigInteger());
        public static Int248 operator /(Int248 dividend, Int248 divisor) => new Int248(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static Int248 operator >>(Int248 value, int shift) => new Int248(value.ToBigInteger() >> shift);
        public static Int248 operator <<(Int248 value, int shift) => new Int248(value.ToBigInteger() << shift);
        public static Int248 operator |(Int248 left, Int248 right) => new Int248(left.ToBigInteger() | right.ToBigInteger());
        public static Int248 operator &(Int248 left, Int248 right) => new Int248(left.ToBigInteger() & right.ToBigInteger());
        public static Int248 operator ^(Int248 left, Int248 right) => new Int248(left.ToBigInteger() ^ right.ToBigInteger());
        public static Int248 operator ++(Int248 value) => value + One;
        public static Int248 operator --(Int248 value) => value - One;
        public static Int248 operator ~(Int248 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new Int248(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(Int248 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(Int248 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(Int248 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(Int248 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(Int248 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(Int248 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(Int248 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(Int248 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(Int248 value) => (float)value.ToBigInteger();
        public static explicit operator double(Int248 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(Int248 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(Int248 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static implicit operator Int248(sbyte value) => new Int248(value);
        public static implicit operator Int248(byte value) => new Int248(value);
        public static implicit operator Int248(short value) => new Int248(value);
        public static implicit operator Int248(ushort value) => new Int248(value);
        public static implicit operator Int248(int value) => new Int248(value);
        public static implicit operator Int248(uint value) => new Int248(value);
        public static implicit operator Int248(long value) => new Int248(value);
        public static implicit operator Int248(ulong value) => new Int248(value);
        public static explicit operator Int248(float value) => FromFloatingType(value);
        public static explicit operator Int248(double value) => FromFloatingType(value);
        public static explicit operator Int248(decimal value) => FromDecimalType(value);
        public static explicit operator Int248(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator Int248(BigInteger value) => new Int248(value);

        // Sibling Types -> This Type
        public static implicit operator Int248(Int24 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int40 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int48 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int56 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int72 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int80 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int88 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int96 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int104 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int112 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int120 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int128 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int136 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int144 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int152 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int160 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int168 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int176 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int184 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int192 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int200 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int208 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int216 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int224 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int232 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(Int240 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt24 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt40 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt48 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt56 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt72 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt80 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt88 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt96 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt104 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt112 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt120 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt128 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt136 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt144 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt152 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt160 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt168 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt176 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt184 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt192 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt200 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt208 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt216 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt224 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt232 value) => new Int248(value.ToBigInteger());
        public static implicit operator Int248(UInt240 value) => new Int248(value.ToBigInteger());
        public static explicit operator Int248(UInt248 value) => new Int248(value.ToBigInteger());

        public static Int248 DivRem(Int248 dividend, Int248 divisor, out Int248 remainder)
        {
            BigInteger remainderBigInt;
            var result = new Int248(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new Int248(remainderBigInt);
            return result;
        }

        public static Int248 Pow(Int248 value, int exponent) => new Int248(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(Int248 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static Int248 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(Int248)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(Int248)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(Int248)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int248)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int248)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int248)})");
            }

            return new Int248(bigInt);
        }

        static Int248 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(Int248)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(Int248)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(Int248)})");
            }

            return new Int248(bigInt);
        }

        public static Int248 Parse(string value, IFormatProvider provider) => new Int248(BigInteger.Parse("0" + value, provider));
        public static Int248 Parse(string value, NumberStyles style) => new Int248(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static Int248 Parse(string value, NumberStyles style, IFormatProvider provider) => new Int248(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static Int248 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static Int248 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(Int248)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new Int248(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out Int248 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out Int248 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(Int248)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new Int248(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static Int248 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static Int248 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(Int248 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is Int248))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(Int248)}");
            }

            // Compare the underlying object
            return CompareTo((Int248)obj);
        }

        public bool Equals(Int248 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is Int248 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((Int248)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25, _b26, _b27, _b28, _b29, _b30).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out Int248 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<Int248>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref Int248 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(Int248)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<Int248>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref Int248 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    #endregion

    #region Unsigned Types
    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt24 : IIntegerBase, IComparable, IComparable<UInt24>, IEquatable<UInt24>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 3;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt24 MaxValue = new UInt24(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt24 MinValue = new UInt24(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt24 Zero = new UInt24(0);
        public static readonly UInt24 One = new UInt24(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt24(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt24(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt24 left, UInt24 right) => !(left == right);
        public static bool operator ==(UInt24 left, UInt24 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt24 left, UInt24 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt24 left, UInt24 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt24 left, UInt24 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt24 left, UInt24 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt24 operator %(UInt24 dividend, UInt24 divisor) => new UInt24(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt24 operator +(UInt24 left, UInt24 right) => new UInt24(left.ToBigInteger() + right.ToBigInteger());
        public static UInt24 operator -(UInt24 left, UInt24 right) => new UInt24(left.ToBigInteger() - right.ToBigInteger());
        public static UInt24 operator *(UInt24 left, UInt24 right) => new UInt24(left.ToBigInteger() * right.ToBigInteger());
        public static UInt24 operator /(UInt24 dividend, UInt24 divisor) => new UInt24(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt24 operator >>(UInt24 value, int shift) => new UInt24(value.ToBigInteger() >> shift);
        public static UInt24 operator <<(UInt24 value, int shift) => new UInt24(value.ToBigInteger() << shift);
        public static UInt24 operator |(UInt24 left, UInt24 right) => new UInt24(left.ToBigInteger() | right.ToBigInteger());
        public static UInt24 operator &(UInt24 left, UInt24 right) => new UInt24(left.ToBigInteger() & right.ToBigInteger());
        public static UInt24 operator ^(UInt24 left, UInt24 right) => new UInt24(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt24 operator ++(UInt24 value) => value + One;
        public static UInt24 operator --(UInt24 value) => value - One;
        public static UInt24 operator ~(UInt24 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt24(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt24 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt24 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt24 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt24 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static implicit operator int(UInt24 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static implicit operator uint(UInt24 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static implicit operator long(UInt24 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static implicit operator ulong(UInt24 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt24 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt24 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt24 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt24 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt24(sbyte value) => new UInt24(value);
        public static implicit operator UInt24(byte value) => new UInt24(value);
        public static explicit operator UInt24(short value) => new UInt24(value);
        public static implicit operator UInt24(ushort value) => new UInt24(value);
        public static explicit operator UInt24(int value) => new UInt24(value);
        public static explicit operator UInt24(uint value) => new UInt24(value);
        public static explicit operator UInt24(long value) => new UInt24(value);
        public static explicit operator UInt24(ulong value) => new UInt24(value);
        public static explicit operator UInt24(float value) => FromFloatingType(value);
        public static explicit operator UInt24(double value) => FromFloatingType(value);
        public static explicit operator UInt24(decimal value) => FromDecimalType(value);
        public static explicit operator UInt24(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt24(BigInteger value) => new UInt24(value);

        // Sibling Types -> This Type
        public static explicit operator UInt24(Int24 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int40 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int48 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int56 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int72 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int80 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int88 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int96 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int104 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int112 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int120 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int128 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int136 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int144 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int152 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int160 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int168 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int176 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int184 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int192 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int200 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int208 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int216 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int224 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int232 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int240 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(Int248 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt40 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt48 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt56 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt72 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt80 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt88 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt96 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt104 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt112 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt120 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt128 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt136 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt144 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt152 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt160 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt168 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt176 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt184 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt192 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt200 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt208 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt216 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt224 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt232 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt240 value) => new UInt24(value.ToBigInteger());
        public static explicit operator UInt24(UInt248 value) => new UInt24(value.ToBigInteger());

        public static UInt24 DivRem(UInt24 dividend, UInt24 divisor, out UInt24 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt24(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt24(remainderBigInt);
            return result;
        }

        public static UInt24 Pow(UInt24 value, int exponent) => new UInt24(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt24 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt24 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt24)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt24)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt24)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt24)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt24)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt24)})");
            }

            return new UInt24(bigInt);
        }

        static UInt24 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt24)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt24)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt24)})");
            }

            return new UInt24(bigInt);
        }

        public static UInt24 Parse(string value, IFormatProvider provider) => new UInt24(BigInteger.Parse("0" + value, provider));
        public static UInt24 Parse(string value, NumberStyles style) => new UInt24(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt24 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt24(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt24 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt24 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt24)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt24(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt24 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt24 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt24)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt24(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt24 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt24 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt24 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt24))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt24)}");
            }

            // Compare the underlying object
            return CompareTo((UInt24)obj);
        }

        public bool Equals(UInt24 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt24 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt24)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt24 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt24>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt24 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt24)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt24>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt24 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt40 : IIntegerBase, IComparable, IComparable<UInt40>, IEquatable<UInt40>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 5;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt40 MaxValue = new UInt40(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt40 MinValue = new UInt40(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt40 Zero = new UInt40(0);
        public static readonly UInt40 One = new UInt40(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt40(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt40(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt40 left, UInt40 right) => !(left == right);
        public static bool operator ==(UInt40 left, UInt40 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt40 left, UInt40 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt40 left, UInt40 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt40 left, UInt40 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt40 left, UInt40 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt40 operator %(UInt40 dividend, UInt40 divisor) => new UInt40(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt40 operator +(UInt40 left, UInt40 right) => new UInt40(left.ToBigInteger() + right.ToBigInteger());
        public static UInt40 operator -(UInt40 left, UInt40 right) => new UInt40(left.ToBigInteger() - right.ToBigInteger());
        public static UInt40 operator *(UInt40 left, UInt40 right) => new UInt40(left.ToBigInteger() * right.ToBigInteger());
        public static UInt40 operator /(UInt40 dividend, UInt40 divisor) => new UInt40(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt40 operator >>(UInt40 value, int shift) => new UInt40(value.ToBigInteger() >> shift);
        public static UInt40 operator <<(UInt40 value, int shift) => new UInt40(value.ToBigInteger() << shift);
        public static UInt40 operator |(UInt40 left, UInt40 right) => new UInt40(left.ToBigInteger() | right.ToBigInteger());
        public static UInt40 operator &(UInt40 left, UInt40 right) => new UInt40(left.ToBigInteger() & right.ToBigInteger());
        public static UInt40 operator ^(UInt40 left, UInt40 right) => new UInt40(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt40 operator ++(UInt40 value) => value + One;
        public static UInt40 operator --(UInt40 value) => value - One;
        public static UInt40 operator ~(UInt40 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt40(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt40 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt40 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt40 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt40 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt40 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt40 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static implicit operator long(UInt40 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static implicit operator ulong(UInt40 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt40 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt40 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt40 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt40 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt40(sbyte value) => new UInt40(value);
        public static implicit operator UInt40(byte value) => new UInt40(value);
        public static explicit operator UInt40(short value) => new UInt40(value);
        public static implicit operator UInt40(ushort value) => new UInt40(value);
        public static explicit operator UInt40(int value) => new UInt40(value);
        public static implicit operator UInt40(uint value) => new UInt40(value);
        public static explicit operator UInt40(long value) => new UInt40(value);
        public static explicit operator UInt40(ulong value) => new UInt40(value);
        public static explicit operator UInt40(float value) => FromFloatingType(value);
        public static explicit operator UInt40(double value) => FromFloatingType(value);
        public static explicit operator UInt40(decimal value) => FromDecimalType(value);
        public static explicit operator UInt40(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt40(BigInteger value) => new UInt40(value);

        // Sibling Types -> This Type
        public static explicit operator UInt40(Int24 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int40 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int48 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int56 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int72 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int80 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int88 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int96 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int104 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int112 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int120 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int128 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int136 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int144 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int152 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int160 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int168 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int176 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int184 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int192 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int200 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int208 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int216 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int224 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int232 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int240 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(Int248 value) => new UInt40(value.ToBigInteger());
        public static implicit operator UInt40(UInt24 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt48 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt56 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt72 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt80 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt88 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt96 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt104 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt112 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt120 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt128 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt136 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt144 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt152 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt160 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt168 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt176 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt184 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt192 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt200 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt208 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt216 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt224 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt232 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt240 value) => new UInt40(value.ToBigInteger());
        public static explicit operator UInt40(UInt248 value) => new UInt40(value.ToBigInteger());

        public static UInt40 DivRem(UInt40 dividend, UInt40 divisor, out UInt40 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt40(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt40(remainderBigInt);
            return result;
        }

        public static UInt40 Pow(UInt40 value, int exponent) => new UInt40(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt40 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt40 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt40)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt40)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt40)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt40)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt40)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt40)})");
            }

            return new UInt40(bigInt);
        }

        static UInt40 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt40)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt40)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt40)})");
            }

            return new UInt40(bigInt);
        }

        public static UInt40 Parse(string value, IFormatProvider provider) => new UInt40(BigInteger.Parse("0" + value, provider));
        public static UInt40 Parse(string value, NumberStyles style) => new UInt40(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt40 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt40(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt40 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt40 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt40)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt40(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt40 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt40 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt40)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt40(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt40 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt40 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt40 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt40))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt40)}");
            }

            // Compare the underlying object
            return CompareTo((UInt40)obj);
        }

        public bool Equals(UInt40 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt40 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt40)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt40 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt40>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt40 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt40)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt40>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt40 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt48 : IIntegerBase, IComparable, IComparable<UInt48>, IEquatable<UInt48>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 6;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt48 MaxValue = new UInt48(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt48 MinValue = new UInt48(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt48 Zero = new UInt48(0);
        public static readonly UInt48 One = new UInt48(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt48(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt48(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt48 left, UInt48 right) => !(left == right);
        public static bool operator ==(UInt48 left, UInt48 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt48 left, UInt48 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt48 left, UInt48 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt48 left, UInt48 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt48 left, UInt48 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt48 operator %(UInt48 dividend, UInt48 divisor) => new UInt48(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt48 operator +(UInt48 left, UInt48 right) => new UInt48(left.ToBigInteger() + right.ToBigInteger());
        public static UInt48 operator -(UInt48 left, UInt48 right) => new UInt48(left.ToBigInteger() - right.ToBigInteger());
        public static UInt48 operator *(UInt48 left, UInt48 right) => new UInt48(left.ToBigInteger() * right.ToBigInteger());
        public static UInt48 operator /(UInt48 dividend, UInt48 divisor) => new UInt48(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt48 operator >>(UInt48 value, int shift) => new UInt48(value.ToBigInteger() >> shift);
        public static UInt48 operator <<(UInt48 value, int shift) => new UInt48(value.ToBigInteger() << shift);
        public static UInt48 operator |(UInt48 left, UInt48 right) => new UInt48(left.ToBigInteger() | right.ToBigInteger());
        public static UInt48 operator &(UInt48 left, UInt48 right) => new UInt48(left.ToBigInteger() & right.ToBigInteger());
        public static UInt48 operator ^(UInt48 left, UInt48 right) => new UInt48(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt48 operator ++(UInt48 value) => value + One;
        public static UInt48 operator --(UInt48 value) => value - One;
        public static UInt48 operator ~(UInt48 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt48(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt48 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt48 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt48 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt48 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt48 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt48 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static implicit operator long(UInt48 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static implicit operator ulong(UInt48 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt48 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt48 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt48 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt48 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt48(sbyte value) => new UInt48(value);
        public static implicit operator UInt48(byte value) => new UInt48(value);
        public static explicit operator UInt48(short value) => new UInt48(value);
        public static implicit operator UInt48(ushort value) => new UInt48(value);
        public static explicit operator UInt48(int value) => new UInt48(value);
        public static implicit operator UInt48(uint value) => new UInt48(value);
        public static explicit operator UInt48(long value) => new UInt48(value);
        public static explicit operator UInt48(ulong value) => new UInt48(value);
        public static explicit operator UInt48(float value) => FromFloatingType(value);
        public static explicit operator UInt48(double value) => FromFloatingType(value);
        public static explicit operator UInt48(decimal value) => FromDecimalType(value);
        public static explicit operator UInt48(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt48(BigInteger value) => new UInt48(value);

        // Sibling Types -> This Type
        public static explicit operator UInt48(Int24 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int40 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int48 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int56 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int72 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int80 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int88 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int96 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int104 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int112 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int120 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int128 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int136 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int144 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int152 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int160 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int168 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int176 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int184 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int192 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int200 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int208 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int216 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int224 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int232 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int240 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(Int248 value) => new UInt48(value.ToBigInteger());
        public static implicit operator UInt48(UInt24 value) => new UInt48(value.ToBigInteger());
        public static implicit operator UInt48(UInt40 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt56 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt72 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt80 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt88 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt96 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt104 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt112 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt120 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt128 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt136 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt144 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt152 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt160 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt168 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt176 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt184 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt192 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt200 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt208 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt216 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt224 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt232 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt240 value) => new UInt48(value.ToBigInteger());
        public static explicit operator UInt48(UInt248 value) => new UInt48(value.ToBigInteger());

        public static UInt48 DivRem(UInt48 dividend, UInt48 divisor, out UInt48 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt48(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt48(remainderBigInt);
            return result;
        }

        public static UInt48 Pow(UInt48 value, int exponent) => new UInt48(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt48 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt48 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt48)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt48)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt48)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt48)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt48)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt48)})");
            }

            return new UInt48(bigInt);
        }

        static UInt48 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt48)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt48)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt48)})");
            }

            return new UInt48(bigInt);
        }

        public static UInt48 Parse(string value, IFormatProvider provider) => new UInt48(BigInteger.Parse("0" + value, provider));
        public static UInt48 Parse(string value, NumberStyles style) => new UInt48(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt48 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt48(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt48 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt48 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt48)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt48(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt48 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt48 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt48)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt48(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt48 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt48 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt48 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt48))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt48)}");
            }

            // Compare the underlying object
            return CompareTo((UInt48)obj);
        }

        public bool Equals(UInt48 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt48 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt48)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt48 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt48>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt48 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt48)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt48>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt48 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt56 : IIntegerBase, IComparable, IComparable<UInt56>, IEquatable<UInt56>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 7;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt56 MaxValue = new UInt56(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt56 MinValue = new UInt56(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt56 Zero = new UInt56(0);
        public static readonly UInt56 One = new UInt56(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt56(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt56(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt56 left, UInt56 right) => !(left == right);
        public static bool operator ==(UInt56 left, UInt56 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt56 left, UInt56 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt56 left, UInt56 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt56 left, UInt56 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt56 left, UInt56 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt56 operator %(UInt56 dividend, UInt56 divisor) => new UInt56(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt56 operator +(UInt56 left, UInt56 right) => new UInt56(left.ToBigInteger() + right.ToBigInteger());
        public static UInt56 operator -(UInt56 left, UInt56 right) => new UInt56(left.ToBigInteger() - right.ToBigInteger());
        public static UInt56 operator *(UInt56 left, UInt56 right) => new UInt56(left.ToBigInteger() * right.ToBigInteger());
        public static UInt56 operator /(UInt56 dividend, UInt56 divisor) => new UInt56(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt56 operator >>(UInt56 value, int shift) => new UInt56(value.ToBigInteger() >> shift);
        public static UInt56 operator <<(UInt56 value, int shift) => new UInt56(value.ToBigInteger() << shift);
        public static UInt56 operator |(UInt56 left, UInt56 right) => new UInt56(left.ToBigInteger() | right.ToBigInteger());
        public static UInt56 operator &(UInt56 left, UInt56 right) => new UInt56(left.ToBigInteger() & right.ToBigInteger());
        public static UInt56 operator ^(UInt56 left, UInt56 right) => new UInt56(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt56 operator ++(UInt56 value) => value + One;
        public static UInt56 operator --(UInt56 value) => value - One;
        public static UInt56 operator ~(UInt56 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt56(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt56 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt56 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt56 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt56 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt56 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt56 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static implicit operator long(UInt56 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static implicit operator ulong(UInt56 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt56 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt56 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt56 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt56 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt56(sbyte value) => new UInt56(value);
        public static implicit operator UInt56(byte value) => new UInt56(value);
        public static explicit operator UInt56(short value) => new UInt56(value);
        public static implicit operator UInt56(ushort value) => new UInt56(value);
        public static explicit operator UInt56(int value) => new UInt56(value);
        public static implicit operator UInt56(uint value) => new UInt56(value);
        public static explicit operator UInt56(long value) => new UInt56(value);
        public static explicit operator UInt56(ulong value) => new UInt56(value);
        public static explicit operator UInt56(float value) => FromFloatingType(value);
        public static explicit operator UInt56(double value) => FromFloatingType(value);
        public static explicit operator UInt56(decimal value) => FromDecimalType(value);
        public static explicit operator UInt56(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt56(BigInteger value) => new UInt56(value);

        // Sibling Types -> This Type
        public static explicit operator UInt56(Int24 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int40 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int48 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int56 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int72 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int80 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int88 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int96 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int104 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int112 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int120 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int128 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int136 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int144 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int152 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int160 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int168 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int176 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int184 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int192 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int200 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int208 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int216 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int224 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int232 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int240 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(Int248 value) => new UInt56(value.ToBigInteger());
        public static implicit operator UInt56(UInt24 value) => new UInt56(value.ToBigInteger());
        public static implicit operator UInt56(UInt40 value) => new UInt56(value.ToBigInteger());
        public static implicit operator UInt56(UInt48 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt72 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt80 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt88 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt96 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt104 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt112 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt120 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt128 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt136 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt144 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt152 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt160 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt168 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt176 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt184 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt192 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt200 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt208 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt216 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt224 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt232 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt240 value) => new UInt56(value.ToBigInteger());
        public static explicit operator UInt56(UInt248 value) => new UInt56(value.ToBigInteger());

        public static UInt56 DivRem(UInt56 dividend, UInt56 divisor, out UInt56 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt56(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt56(remainderBigInt);
            return result;
        }

        public static UInt56 Pow(UInt56 value, int exponent) => new UInt56(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt56 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt56 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt56)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt56)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt56)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt56)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt56)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt56)})");
            }

            return new UInt56(bigInt);
        }

        static UInt56 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt56)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt56)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt56)})");
            }

            return new UInt56(bigInt);
        }

        public static UInt56 Parse(string value, IFormatProvider provider) => new UInt56(BigInteger.Parse("0" + value, provider));
        public static UInt56 Parse(string value, NumberStyles style) => new UInt56(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt56 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt56(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt56 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt56 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt56)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt56(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt56 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt56 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt56)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt56(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt56 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt56 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt56 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt56))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt56)}");
            }

            // Compare the underlying object
            return CompareTo((UInt56)obj);
        }

        public bool Equals(UInt56 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt56 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt56)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt56 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt56>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt56 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt56)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt56>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt56 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt72 : IIntegerBase, IComparable, IComparable<UInt72>, IEquatable<UInt72>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 9;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt72 MaxValue = new UInt72(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt72 MinValue = new UInt72(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt72 Zero = new UInt72(0);
        public static readonly UInt72 One = new UInt72(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt72(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt72(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt72 left, UInt72 right) => !(left == right);
        public static bool operator ==(UInt72 left, UInt72 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt72 left, UInt72 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt72 left, UInt72 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt72 left, UInt72 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt72 left, UInt72 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt72 operator %(UInt72 dividend, UInt72 divisor) => new UInt72(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt72 operator +(UInt72 left, UInt72 right) => new UInt72(left.ToBigInteger() + right.ToBigInteger());
        public static UInt72 operator -(UInt72 left, UInt72 right) => new UInt72(left.ToBigInteger() - right.ToBigInteger());
        public static UInt72 operator *(UInt72 left, UInt72 right) => new UInt72(left.ToBigInteger() * right.ToBigInteger());
        public static UInt72 operator /(UInt72 dividend, UInt72 divisor) => new UInt72(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt72 operator >>(UInt72 value, int shift) => new UInt72(value.ToBigInteger() >> shift);
        public static UInt72 operator <<(UInt72 value, int shift) => new UInt72(value.ToBigInteger() << shift);
        public static UInt72 operator |(UInt72 left, UInt72 right) => new UInt72(left.ToBigInteger() | right.ToBigInteger());
        public static UInt72 operator &(UInt72 left, UInt72 right) => new UInt72(left.ToBigInteger() & right.ToBigInteger());
        public static UInt72 operator ^(UInt72 left, UInt72 right) => new UInt72(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt72 operator ++(UInt72 value) => value + One;
        public static UInt72 operator --(UInt72 value) => value - One;
        public static UInt72 operator ~(UInt72 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt72(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt72 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt72 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt72 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt72 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt72 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt72 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt72 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt72 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt72 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt72 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt72 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt72 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt72(sbyte value) => new UInt72(value);
        public static implicit operator UInt72(byte value) => new UInt72(value);
        public static explicit operator UInt72(short value) => new UInt72(value);
        public static implicit operator UInt72(ushort value) => new UInt72(value);
        public static explicit operator UInt72(int value) => new UInt72(value);
        public static implicit operator UInt72(uint value) => new UInt72(value);
        public static explicit operator UInt72(long value) => new UInt72(value);
        public static implicit operator UInt72(ulong value) => new UInt72(value);
        public static explicit operator UInt72(float value) => FromFloatingType(value);
        public static explicit operator UInt72(double value) => FromFloatingType(value);
        public static explicit operator UInt72(decimal value) => FromDecimalType(value);
        public static explicit operator UInt72(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt72(BigInteger value) => new UInt72(value);

        // Sibling Types -> This Type
        public static explicit operator UInt72(Int24 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int40 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int48 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int56 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int72 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int80 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int88 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int96 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int104 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int112 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int120 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int128 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int136 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int144 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int152 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int160 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int168 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int176 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int184 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int192 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int200 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int208 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int216 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int224 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int232 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int240 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(Int248 value) => new UInt72(value.ToBigInteger());
        public static implicit operator UInt72(UInt24 value) => new UInt72(value.ToBigInteger());
        public static implicit operator UInt72(UInt40 value) => new UInt72(value.ToBigInteger());
        public static implicit operator UInt72(UInt48 value) => new UInt72(value.ToBigInteger());
        public static implicit operator UInt72(UInt56 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt80 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt88 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt96 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt104 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt112 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt120 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt128 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt136 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt144 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt152 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt160 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt168 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt176 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt184 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt192 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt200 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt208 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt216 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt224 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt232 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt240 value) => new UInt72(value.ToBigInteger());
        public static explicit operator UInt72(UInt248 value) => new UInt72(value.ToBigInteger());

        public static UInt72 DivRem(UInt72 dividend, UInt72 divisor, out UInt72 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt72(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt72(remainderBigInt);
            return result;
        }

        public static UInt72 Pow(UInt72 value, int exponent) => new UInt72(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt72 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt72 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt72)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt72)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt72)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt72)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt72)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt72)})");
            }

            return new UInt72(bigInt);
        }

        static UInt72 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt72)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt72)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt72)})");
            }

            return new UInt72(bigInt);
        }

        public static UInt72 Parse(string value, IFormatProvider provider) => new UInt72(BigInteger.Parse("0" + value, provider));
        public static UInt72 Parse(string value, NumberStyles style) => new UInt72(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt72 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt72(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt72 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt72 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt72)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt72(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt72 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt72 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt72)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt72(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt72 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt72 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt72 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt72))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt72)}");
            }

            // Compare the underlying object
            return CompareTo((UInt72)obj);
        }

        public bool Equals(UInt72 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt72 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt72)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt72 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt72>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt72 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt72)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt72>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt72 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt80 : IIntegerBase, IComparable, IComparable<UInt80>, IEquatable<UInt80>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 10;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt80 MaxValue = new UInt80(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt80 MinValue = new UInt80(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt80 Zero = new UInt80(0);
        public static readonly UInt80 One = new UInt80(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt80(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt80(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt80 left, UInt80 right) => !(left == right);
        public static bool operator ==(UInt80 left, UInt80 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt80 left, UInt80 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt80 left, UInt80 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt80 left, UInt80 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt80 left, UInt80 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt80 operator %(UInt80 dividend, UInt80 divisor) => new UInt80(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt80 operator +(UInt80 left, UInt80 right) => new UInt80(left.ToBigInteger() + right.ToBigInteger());
        public static UInt80 operator -(UInt80 left, UInt80 right) => new UInt80(left.ToBigInteger() - right.ToBigInteger());
        public static UInt80 operator *(UInt80 left, UInt80 right) => new UInt80(left.ToBigInteger() * right.ToBigInteger());
        public static UInt80 operator /(UInt80 dividend, UInt80 divisor) => new UInt80(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt80 operator >>(UInt80 value, int shift) => new UInt80(value.ToBigInteger() >> shift);
        public static UInt80 operator <<(UInt80 value, int shift) => new UInt80(value.ToBigInteger() << shift);
        public static UInt80 operator |(UInt80 left, UInt80 right) => new UInt80(left.ToBigInteger() | right.ToBigInteger());
        public static UInt80 operator &(UInt80 left, UInt80 right) => new UInt80(left.ToBigInteger() & right.ToBigInteger());
        public static UInt80 operator ^(UInt80 left, UInt80 right) => new UInt80(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt80 operator ++(UInt80 value) => value + One;
        public static UInt80 operator --(UInt80 value) => value - One;
        public static UInt80 operator ~(UInt80 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt80(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt80 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt80 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt80 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt80 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt80 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt80 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt80 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt80 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt80 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt80 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt80 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt80 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt80(sbyte value) => new UInt80(value);
        public static implicit operator UInt80(byte value) => new UInt80(value);
        public static explicit operator UInt80(short value) => new UInt80(value);
        public static implicit operator UInt80(ushort value) => new UInt80(value);
        public static explicit operator UInt80(int value) => new UInt80(value);
        public static implicit operator UInt80(uint value) => new UInt80(value);
        public static explicit operator UInt80(long value) => new UInt80(value);
        public static implicit operator UInt80(ulong value) => new UInt80(value);
        public static explicit operator UInt80(float value) => FromFloatingType(value);
        public static explicit operator UInt80(double value) => FromFloatingType(value);
        public static explicit operator UInt80(decimal value) => FromDecimalType(value);
        public static explicit operator UInt80(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt80(BigInteger value) => new UInt80(value);

        // Sibling Types -> This Type
        public static explicit operator UInt80(Int24 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int40 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int48 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int56 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int72 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int80 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int88 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int96 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int104 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int112 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int120 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int128 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int136 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int144 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int152 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int160 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int168 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int176 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int184 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int192 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int200 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int208 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int216 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int224 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int232 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int240 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(Int248 value) => new UInt80(value.ToBigInteger());
        public static implicit operator UInt80(UInt24 value) => new UInt80(value.ToBigInteger());
        public static implicit operator UInt80(UInt40 value) => new UInt80(value.ToBigInteger());
        public static implicit operator UInt80(UInt48 value) => new UInt80(value.ToBigInteger());
        public static implicit operator UInt80(UInt56 value) => new UInt80(value.ToBigInteger());
        public static implicit operator UInt80(UInt72 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt88 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt96 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt104 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt112 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt120 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt128 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt136 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt144 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt152 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt160 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt168 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt176 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt184 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt192 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt200 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt208 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt216 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt224 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt232 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt240 value) => new UInt80(value.ToBigInteger());
        public static explicit operator UInt80(UInt248 value) => new UInt80(value.ToBigInteger());

        public static UInt80 DivRem(UInt80 dividend, UInt80 divisor, out UInt80 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt80(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt80(remainderBigInt);
            return result;
        }

        public static UInt80 Pow(UInt80 value, int exponent) => new UInt80(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt80 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt80 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt80)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt80)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt80)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt80)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt80)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt80)})");
            }

            return new UInt80(bigInt);
        }

        static UInt80 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt80)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt80)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt80)})");
            }

            return new UInt80(bigInt);
        }

        public static UInt80 Parse(string value, IFormatProvider provider) => new UInt80(BigInteger.Parse("0" + value, provider));
        public static UInt80 Parse(string value, NumberStyles style) => new UInt80(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt80 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt80(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt80 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt80 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt80)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt80(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt80 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt80 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt80)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt80(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt80 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt80 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt80 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt80))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt80)}");
            }

            // Compare the underlying object
            return CompareTo((UInt80)obj);
        }

        public bool Equals(UInt80 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt80 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt80)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt80 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt80>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt80 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt80)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt80>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt80 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt88 : IIntegerBase, IComparable, IComparable<UInt88>, IEquatable<UInt88>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 11;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt88 MaxValue = new UInt88(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt88 MinValue = new UInt88(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt88 Zero = new UInt88(0);
        public static readonly UInt88 One = new UInt88(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt88(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt88(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt88 left, UInt88 right) => !(left == right);
        public static bool operator ==(UInt88 left, UInt88 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt88 left, UInt88 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt88 left, UInt88 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt88 left, UInt88 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt88 left, UInt88 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt88 operator %(UInt88 dividend, UInt88 divisor) => new UInt88(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt88 operator +(UInt88 left, UInt88 right) => new UInt88(left.ToBigInteger() + right.ToBigInteger());
        public static UInt88 operator -(UInt88 left, UInt88 right) => new UInt88(left.ToBigInteger() - right.ToBigInteger());
        public static UInt88 operator *(UInt88 left, UInt88 right) => new UInt88(left.ToBigInteger() * right.ToBigInteger());
        public static UInt88 operator /(UInt88 dividend, UInt88 divisor) => new UInt88(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt88 operator >>(UInt88 value, int shift) => new UInt88(value.ToBigInteger() >> shift);
        public static UInt88 operator <<(UInt88 value, int shift) => new UInt88(value.ToBigInteger() << shift);
        public static UInt88 operator |(UInt88 left, UInt88 right) => new UInt88(left.ToBigInteger() | right.ToBigInteger());
        public static UInt88 operator &(UInt88 left, UInt88 right) => new UInt88(left.ToBigInteger() & right.ToBigInteger());
        public static UInt88 operator ^(UInt88 left, UInt88 right) => new UInt88(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt88 operator ++(UInt88 value) => value + One;
        public static UInt88 operator --(UInt88 value) => value - One;
        public static UInt88 operator ~(UInt88 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt88(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt88 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt88 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt88 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt88 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt88 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt88 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt88 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt88 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt88 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt88 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt88 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt88 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt88(sbyte value) => new UInt88(value);
        public static implicit operator UInt88(byte value) => new UInt88(value);
        public static explicit operator UInt88(short value) => new UInt88(value);
        public static implicit operator UInt88(ushort value) => new UInt88(value);
        public static explicit operator UInt88(int value) => new UInt88(value);
        public static implicit operator UInt88(uint value) => new UInt88(value);
        public static explicit operator UInt88(long value) => new UInt88(value);
        public static implicit operator UInt88(ulong value) => new UInt88(value);
        public static explicit operator UInt88(float value) => FromFloatingType(value);
        public static explicit operator UInt88(double value) => FromFloatingType(value);
        public static explicit operator UInt88(decimal value) => FromDecimalType(value);
        public static explicit operator UInt88(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt88(BigInteger value) => new UInt88(value);

        // Sibling Types -> This Type
        public static explicit operator UInt88(Int24 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int40 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int48 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int56 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int72 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int80 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int88 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int96 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int104 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int112 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int120 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int128 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int136 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int144 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int152 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int160 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int168 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int176 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int184 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int192 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int200 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int208 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int216 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int224 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int232 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int240 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(Int248 value) => new UInt88(value.ToBigInteger());
        public static implicit operator UInt88(UInt24 value) => new UInt88(value.ToBigInteger());
        public static implicit operator UInt88(UInt40 value) => new UInt88(value.ToBigInteger());
        public static implicit operator UInt88(UInt48 value) => new UInt88(value.ToBigInteger());
        public static implicit operator UInt88(UInt56 value) => new UInt88(value.ToBigInteger());
        public static implicit operator UInt88(UInt72 value) => new UInt88(value.ToBigInteger());
        public static implicit operator UInt88(UInt80 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt96 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt104 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt112 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt120 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt128 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt136 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt144 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt152 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt160 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt168 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt176 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt184 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt192 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt200 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt208 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt216 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt224 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt232 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt240 value) => new UInt88(value.ToBigInteger());
        public static explicit operator UInt88(UInt248 value) => new UInt88(value.ToBigInteger());

        public static UInt88 DivRem(UInt88 dividend, UInt88 divisor, out UInt88 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt88(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt88(remainderBigInt);
            return result;
        }

        public static UInt88 Pow(UInt88 value, int exponent) => new UInt88(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt88 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt88 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt88)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt88)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt88)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt88)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt88)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt88)})");
            }

            return new UInt88(bigInt);
        }

        static UInt88 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt88)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt88)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt88)})");
            }

            return new UInt88(bigInt);
        }

        public static UInt88 Parse(string value, IFormatProvider provider) => new UInt88(BigInteger.Parse("0" + value, provider));
        public static UInt88 Parse(string value, NumberStyles style) => new UInt88(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt88 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt88(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt88 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt88 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt88)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt88(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt88 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt88 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt88)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt88(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt88 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt88 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt88 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt88))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt88)}");
            }

            // Compare the underlying object
            return CompareTo((UInt88)obj);
        }

        public bool Equals(UInt88 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt88 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt88)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt88 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt88>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt88 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt88)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt88>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt88 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt96 : IIntegerBase, IComparable, IComparable<UInt96>, IEquatable<UInt96>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 12;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt96 MaxValue = new UInt96(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt96 MinValue = new UInt96(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt96 Zero = new UInt96(0);
        public static readonly UInt96 One = new UInt96(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt96(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt96(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt96 left, UInt96 right) => !(left == right);
        public static bool operator ==(UInt96 left, UInt96 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt96 left, UInt96 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt96 left, UInt96 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt96 left, UInt96 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt96 left, UInt96 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt96 operator %(UInt96 dividend, UInt96 divisor) => new UInt96(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt96 operator +(UInt96 left, UInt96 right) => new UInt96(left.ToBigInteger() + right.ToBigInteger());
        public static UInt96 operator -(UInt96 left, UInt96 right) => new UInt96(left.ToBigInteger() - right.ToBigInteger());
        public static UInt96 operator *(UInt96 left, UInt96 right) => new UInt96(left.ToBigInteger() * right.ToBigInteger());
        public static UInt96 operator /(UInt96 dividend, UInt96 divisor) => new UInt96(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt96 operator >>(UInt96 value, int shift) => new UInt96(value.ToBigInteger() >> shift);
        public static UInt96 operator <<(UInt96 value, int shift) => new UInt96(value.ToBigInteger() << shift);
        public static UInt96 operator |(UInt96 left, UInt96 right) => new UInt96(left.ToBigInteger() | right.ToBigInteger());
        public static UInt96 operator &(UInt96 left, UInt96 right) => new UInt96(left.ToBigInteger() & right.ToBigInteger());
        public static UInt96 operator ^(UInt96 left, UInt96 right) => new UInt96(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt96 operator ++(UInt96 value) => value + One;
        public static UInt96 operator --(UInt96 value) => value - One;
        public static UInt96 operator ~(UInt96 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt96(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt96 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt96 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt96 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt96 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt96 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt96 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt96 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt96 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt96 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt96 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt96 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt96 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt96(sbyte value) => new UInt96(value);
        public static implicit operator UInt96(byte value) => new UInt96(value);
        public static explicit operator UInt96(short value) => new UInt96(value);
        public static implicit operator UInt96(ushort value) => new UInt96(value);
        public static explicit operator UInt96(int value) => new UInt96(value);
        public static implicit operator UInt96(uint value) => new UInt96(value);
        public static explicit operator UInt96(long value) => new UInt96(value);
        public static implicit operator UInt96(ulong value) => new UInt96(value);
        public static explicit operator UInt96(float value) => FromFloatingType(value);
        public static explicit operator UInt96(double value) => FromFloatingType(value);
        public static explicit operator UInt96(decimal value) => FromDecimalType(value);
        public static explicit operator UInt96(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt96(BigInteger value) => new UInt96(value);

        // Sibling Types -> This Type
        public static explicit operator UInt96(Int24 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int40 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int48 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int56 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int72 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int80 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int88 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int96 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int104 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int112 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int120 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int128 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int136 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int144 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int152 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int160 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int168 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int176 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int184 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int192 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int200 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int208 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int216 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int224 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int232 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int240 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(Int248 value) => new UInt96(value.ToBigInteger());
        public static implicit operator UInt96(UInt24 value) => new UInt96(value.ToBigInteger());
        public static implicit operator UInt96(UInt40 value) => new UInt96(value.ToBigInteger());
        public static implicit operator UInt96(UInt48 value) => new UInt96(value.ToBigInteger());
        public static implicit operator UInt96(UInt56 value) => new UInt96(value.ToBigInteger());
        public static implicit operator UInt96(UInt72 value) => new UInt96(value.ToBigInteger());
        public static implicit operator UInt96(UInt80 value) => new UInt96(value.ToBigInteger());
        public static implicit operator UInt96(UInt88 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt104 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt112 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt120 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt128 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt136 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt144 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt152 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt160 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt168 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt176 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt184 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt192 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt200 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt208 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt216 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt224 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt232 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt240 value) => new UInt96(value.ToBigInteger());
        public static explicit operator UInt96(UInt248 value) => new UInt96(value.ToBigInteger());

        public static UInt96 DivRem(UInt96 dividend, UInt96 divisor, out UInt96 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt96(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt96(remainderBigInt);
            return result;
        }

        public static UInt96 Pow(UInt96 value, int exponent) => new UInt96(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt96 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt96 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt96)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt96)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt96)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt96)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt96)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt96)})");
            }

            return new UInt96(bigInt);
        }

        static UInt96 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt96)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt96)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt96)})");
            }

            return new UInt96(bigInt);
        }

        public static UInt96 Parse(string value, IFormatProvider provider) => new UInt96(BigInteger.Parse("0" + value, provider));
        public static UInt96 Parse(string value, NumberStyles style) => new UInt96(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt96 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt96(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt96 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt96 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt96)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt96(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt96 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt96 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt96)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt96(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt96 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt96 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt96 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt96))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt96)}");
            }

            // Compare the underlying object
            return CompareTo((UInt96)obj);
        }

        public bool Equals(UInt96 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt96 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt96)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt96 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt96>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt96 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt96)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt96>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt96 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt104 : IIntegerBase, IComparable, IComparable<UInt104>, IEquatable<UInt104>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 13;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt104 MaxValue = new UInt104(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt104 MinValue = new UInt104(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt104 Zero = new UInt104(0);
        public static readonly UInt104 One = new UInt104(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt104(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt104(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt104 left, UInt104 right) => !(left == right);
        public static bool operator ==(UInt104 left, UInt104 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt104 left, UInt104 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt104 left, UInt104 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt104 left, UInt104 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt104 left, UInt104 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt104 operator %(UInt104 dividend, UInt104 divisor) => new UInt104(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt104 operator +(UInt104 left, UInt104 right) => new UInt104(left.ToBigInteger() + right.ToBigInteger());
        public static UInt104 operator -(UInt104 left, UInt104 right) => new UInt104(left.ToBigInteger() - right.ToBigInteger());
        public static UInt104 operator *(UInt104 left, UInt104 right) => new UInt104(left.ToBigInteger() * right.ToBigInteger());
        public static UInt104 operator /(UInt104 dividend, UInt104 divisor) => new UInt104(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt104 operator >>(UInt104 value, int shift) => new UInt104(value.ToBigInteger() >> shift);
        public static UInt104 operator <<(UInt104 value, int shift) => new UInt104(value.ToBigInteger() << shift);
        public static UInt104 operator |(UInt104 left, UInt104 right) => new UInt104(left.ToBigInteger() | right.ToBigInteger());
        public static UInt104 operator &(UInt104 left, UInt104 right) => new UInt104(left.ToBigInteger() & right.ToBigInteger());
        public static UInt104 operator ^(UInt104 left, UInt104 right) => new UInt104(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt104 operator ++(UInt104 value) => value + One;
        public static UInt104 operator --(UInt104 value) => value - One;
        public static UInt104 operator ~(UInt104 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt104(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt104 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt104 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt104 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt104 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt104 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt104 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt104 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt104 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt104 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt104 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt104 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt104 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt104(sbyte value) => new UInt104(value);
        public static implicit operator UInt104(byte value) => new UInt104(value);
        public static explicit operator UInt104(short value) => new UInt104(value);
        public static implicit operator UInt104(ushort value) => new UInt104(value);
        public static explicit operator UInt104(int value) => new UInt104(value);
        public static implicit operator UInt104(uint value) => new UInt104(value);
        public static explicit operator UInt104(long value) => new UInt104(value);
        public static implicit operator UInt104(ulong value) => new UInt104(value);
        public static explicit operator UInt104(float value) => FromFloatingType(value);
        public static explicit operator UInt104(double value) => FromFloatingType(value);
        public static explicit operator UInt104(decimal value) => FromDecimalType(value);
        public static explicit operator UInt104(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt104(BigInteger value) => new UInt104(value);

        // Sibling Types -> This Type
        public static explicit operator UInt104(Int24 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int40 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int48 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int56 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int72 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int80 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int88 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int96 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int104 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int112 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int120 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int128 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int136 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int144 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int152 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int160 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int168 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int176 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int184 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int192 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int200 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int208 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int216 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int224 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int232 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int240 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(Int248 value) => new UInt104(value.ToBigInteger());
        public static implicit operator UInt104(UInt24 value) => new UInt104(value.ToBigInteger());
        public static implicit operator UInt104(UInt40 value) => new UInt104(value.ToBigInteger());
        public static implicit operator UInt104(UInt48 value) => new UInt104(value.ToBigInteger());
        public static implicit operator UInt104(UInt56 value) => new UInt104(value.ToBigInteger());
        public static implicit operator UInt104(UInt72 value) => new UInt104(value.ToBigInteger());
        public static implicit operator UInt104(UInt80 value) => new UInt104(value.ToBigInteger());
        public static implicit operator UInt104(UInt88 value) => new UInt104(value.ToBigInteger());
        public static implicit operator UInt104(UInt96 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt112 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt120 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt128 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt136 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt144 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt152 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt160 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt168 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt176 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt184 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt192 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt200 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt208 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt216 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt224 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt232 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt240 value) => new UInt104(value.ToBigInteger());
        public static explicit operator UInt104(UInt248 value) => new UInt104(value.ToBigInteger());

        public static UInt104 DivRem(UInt104 dividend, UInt104 divisor, out UInt104 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt104(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt104(remainderBigInt);
            return result;
        }

        public static UInt104 Pow(UInt104 value, int exponent) => new UInt104(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt104 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt104 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt104)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt104)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt104)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt104)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt104)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt104)})");
            }

            return new UInt104(bigInt);
        }

        static UInt104 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt104)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt104)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt104)})");
            }

            return new UInt104(bigInt);
        }

        public static UInt104 Parse(string value, IFormatProvider provider) => new UInt104(BigInteger.Parse("0" + value, provider));
        public static UInt104 Parse(string value, NumberStyles style) => new UInt104(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt104 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt104(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt104 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt104 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt104)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt104(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt104 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt104 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt104)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt104(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt104 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt104 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt104 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt104))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt104)}");
            }

            // Compare the underlying object
            return CompareTo((UInt104)obj);
        }

        public bool Equals(UInt104 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt104 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt104)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt104 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt104>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt104 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt104)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt104>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt104 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt112 : IIntegerBase, IComparable, IComparable<UInt112>, IEquatable<UInt112>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 14;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt112 MaxValue = new UInt112(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt112 MinValue = new UInt112(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt112 Zero = new UInt112(0);
        public static readonly UInt112 One = new UInt112(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt112(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt112(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt112 left, UInt112 right) => !(left == right);
        public static bool operator ==(UInt112 left, UInt112 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt112 left, UInt112 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt112 left, UInt112 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt112 left, UInt112 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt112 left, UInt112 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt112 operator %(UInt112 dividend, UInt112 divisor) => new UInt112(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt112 operator +(UInt112 left, UInt112 right) => new UInt112(left.ToBigInteger() + right.ToBigInteger());
        public static UInt112 operator -(UInt112 left, UInt112 right) => new UInt112(left.ToBigInteger() - right.ToBigInteger());
        public static UInt112 operator *(UInt112 left, UInt112 right) => new UInt112(left.ToBigInteger() * right.ToBigInteger());
        public static UInt112 operator /(UInt112 dividend, UInt112 divisor) => new UInt112(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt112 operator >>(UInt112 value, int shift) => new UInt112(value.ToBigInteger() >> shift);
        public static UInt112 operator <<(UInt112 value, int shift) => new UInt112(value.ToBigInteger() << shift);
        public static UInt112 operator |(UInt112 left, UInt112 right) => new UInt112(left.ToBigInteger() | right.ToBigInteger());
        public static UInt112 operator &(UInt112 left, UInt112 right) => new UInt112(left.ToBigInteger() & right.ToBigInteger());
        public static UInt112 operator ^(UInt112 left, UInt112 right) => new UInt112(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt112 operator ++(UInt112 value) => value + One;
        public static UInt112 operator --(UInt112 value) => value - One;
        public static UInt112 operator ~(UInt112 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt112(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt112 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt112 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt112 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt112 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt112 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt112 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt112 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt112 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt112 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt112 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt112 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt112 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt112(sbyte value) => new UInt112(value);
        public static implicit operator UInt112(byte value) => new UInt112(value);
        public static explicit operator UInt112(short value) => new UInt112(value);
        public static implicit operator UInt112(ushort value) => new UInt112(value);
        public static explicit operator UInt112(int value) => new UInt112(value);
        public static implicit operator UInt112(uint value) => new UInt112(value);
        public static explicit operator UInt112(long value) => new UInt112(value);
        public static implicit operator UInt112(ulong value) => new UInt112(value);
        public static explicit operator UInt112(float value) => FromFloatingType(value);
        public static explicit operator UInt112(double value) => FromFloatingType(value);
        public static explicit operator UInt112(decimal value) => FromDecimalType(value);
        public static explicit operator UInt112(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt112(BigInteger value) => new UInt112(value);

        // Sibling Types -> This Type
        public static explicit operator UInt112(Int24 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int40 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int48 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int56 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int72 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int80 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int88 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int96 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int104 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int112 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int120 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int128 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int136 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int144 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int152 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int160 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int168 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int176 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int184 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int192 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int200 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int208 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int216 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int224 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int232 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int240 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(Int248 value) => new UInt112(value.ToBigInteger());
        public static implicit operator UInt112(UInt24 value) => new UInt112(value.ToBigInteger());
        public static implicit operator UInt112(UInt40 value) => new UInt112(value.ToBigInteger());
        public static implicit operator UInt112(UInt48 value) => new UInt112(value.ToBigInteger());
        public static implicit operator UInt112(UInt56 value) => new UInt112(value.ToBigInteger());
        public static implicit operator UInt112(UInt72 value) => new UInt112(value.ToBigInteger());
        public static implicit operator UInt112(UInt80 value) => new UInt112(value.ToBigInteger());
        public static implicit operator UInt112(UInt88 value) => new UInt112(value.ToBigInteger());
        public static implicit operator UInt112(UInt96 value) => new UInt112(value.ToBigInteger());
        public static implicit operator UInt112(UInt104 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt120 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt128 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt136 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt144 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt152 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt160 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt168 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt176 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt184 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt192 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt200 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt208 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt216 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt224 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt232 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt240 value) => new UInt112(value.ToBigInteger());
        public static explicit operator UInt112(UInt248 value) => new UInt112(value.ToBigInteger());

        public static UInt112 DivRem(UInt112 dividend, UInt112 divisor, out UInt112 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt112(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt112(remainderBigInt);
            return result;
        }

        public static UInt112 Pow(UInt112 value, int exponent) => new UInt112(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt112 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt112 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt112)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt112)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt112)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt112)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt112)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt112)})");
            }

            return new UInt112(bigInt);
        }

        static UInt112 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt112)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt112)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt112)})");
            }

            return new UInt112(bigInt);
        }

        public static UInt112 Parse(string value, IFormatProvider provider) => new UInt112(BigInteger.Parse("0" + value, provider));
        public static UInt112 Parse(string value, NumberStyles style) => new UInt112(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt112 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt112(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt112 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt112 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt112)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt112(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt112 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt112 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt112)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt112(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt112 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt112 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt112 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt112))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt112)}");
            }

            // Compare the underlying object
            return CompareTo((UInt112)obj);
        }

        public bool Equals(UInt112 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt112 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt112)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt112 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt112>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt112 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt112)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt112>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt112 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt120 : IIntegerBase, IComparable, IComparable<UInt120>, IEquatable<UInt120>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 15;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt120 MaxValue = new UInt120(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt120 MinValue = new UInt120(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt120 Zero = new UInt120(0);
        public static readonly UInt120 One = new UInt120(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt120(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt120(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt120 left, UInt120 right) => !(left == right);
        public static bool operator ==(UInt120 left, UInt120 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt120 left, UInt120 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt120 left, UInt120 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt120 left, UInt120 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt120 left, UInt120 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt120 operator %(UInt120 dividend, UInt120 divisor) => new UInt120(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt120 operator +(UInt120 left, UInt120 right) => new UInt120(left.ToBigInteger() + right.ToBigInteger());
        public static UInt120 operator -(UInt120 left, UInt120 right) => new UInt120(left.ToBigInteger() - right.ToBigInteger());
        public static UInt120 operator *(UInt120 left, UInt120 right) => new UInt120(left.ToBigInteger() * right.ToBigInteger());
        public static UInt120 operator /(UInt120 dividend, UInt120 divisor) => new UInt120(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt120 operator >>(UInt120 value, int shift) => new UInt120(value.ToBigInteger() >> shift);
        public static UInt120 operator <<(UInt120 value, int shift) => new UInt120(value.ToBigInteger() << shift);
        public static UInt120 operator |(UInt120 left, UInt120 right) => new UInt120(left.ToBigInteger() | right.ToBigInteger());
        public static UInt120 operator &(UInt120 left, UInt120 right) => new UInt120(left.ToBigInteger() & right.ToBigInteger());
        public static UInt120 operator ^(UInt120 left, UInt120 right) => new UInt120(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt120 operator ++(UInt120 value) => value + One;
        public static UInt120 operator --(UInt120 value) => value - One;
        public static UInt120 operator ~(UInt120 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt120(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt120 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt120 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt120 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt120 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt120 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt120 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt120 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt120 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt120 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt120 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt120 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt120 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt120(sbyte value) => new UInt120(value);
        public static implicit operator UInt120(byte value) => new UInt120(value);
        public static explicit operator UInt120(short value) => new UInt120(value);
        public static implicit operator UInt120(ushort value) => new UInt120(value);
        public static explicit operator UInt120(int value) => new UInt120(value);
        public static implicit operator UInt120(uint value) => new UInt120(value);
        public static explicit operator UInt120(long value) => new UInt120(value);
        public static implicit operator UInt120(ulong value) => new UInt120(value);
        public static explicit operator UInt120(float value) => FromFloatingType(value);
        public static explicit operator UInt120(double value) => FromFloatingType(value);
        public static explicit operator UInt120(decimal value) => FromDecimalType(value);
        public static explicit operator UInt120(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt120(BigInteger value) => new UInt120(value);

        // Sibling Types -> This Type
        public static explicit operator UInt120(Int24 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int40 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int48 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int56 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int72 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int80 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int88 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int96 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int104 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int112 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int120 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int128 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int136 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int144 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int152 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int160 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int168 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int176 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int184 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int192 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int200 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int208 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int216 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int224 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int232 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int240 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(Int248 value) => new UInt120(value.ToBigInteger());
        public static implicit operator UInt120(UInt24 value) => new UInt120(value.ToBigInteger());
        public static implicit operator UInt120(UInt40 value) => new UInt120(value.ToBigInteger());
        public static implicit operator UInt120(UInt48 value) => new UInt120(value.ToBigInteger());
        public static implicit operator UInt120(UInt56 value) => new UInt120(value.ToBigInteger());
        public static implicit operator UInt120(UInt72 value) => new UInt120(value.ToBigInteger());
        public static implicit operator UInt120(UInt80 value) => new UInt120(value.ToBigInteger());
        public static implicit operator UInt120(UInt88 value) => new UInt120(value.ToBigInteger());
        public static implicit operator UInt120(UInt96 value) => new UInt120(value.ToBigInteger());
        public static implicit operator UInt120(UInt104 value) => new UInt120(value.ToBigInteger());
        public static implicit operator UInt120(UInt112 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt128 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt136 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt144 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt152 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt160 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt168 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt176 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt184 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt192 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt200 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt208 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt216 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt224 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt232 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt240 value) => new UInt120(value.ToBigInteger());
        public static explicit operator UInt120(UInt248 value) => new UInt120(value.ToBigInteger());

        public static UInt120 DivRem(UInt120 dividend, UInt120 divisor, out UInt120 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt120(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt120(remainderBigInt);
            return result;
        }

        public static UInt120 Pow(UInt120 value, int exponent) => new UInt120(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt120 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt120 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt120)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt120)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt120)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt120)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt120)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt120)})");
            }

            return new UInt120(bigInt);
        }

        static UInt120 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt120)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt120)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt120)})");
            }

            return new UInt120(bigInt);
        }

        public static UInt120 Parse(string value, IFormatProvider provider) => new UInt120(BigInteger.Parse("0" + value, provider));
        public static UInt120 Parse(string value, NumberStyles style) => new UInt120(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt120 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt120(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt120 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt120 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt120)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt120(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt120 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt120 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt120)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt120(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt120 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt120 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt120 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt120))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt120)}");
            }

            // Compare the underlying object
            return CompareTo((UInt120)obj);
        }

        public bool Equals(UInt120 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt120 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt120)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt120 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt120>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt120 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt120)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt120>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt120 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt128 : IIntegerBase, IComparable, IComparable<UInt128>, IEquatable<UInt128>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 16;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt128 MaxValue = new UInt128(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt128 MinValue = new UInt128(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt128 Zero = new UInt128(0);
        public static readonly UInt128 One = new UInt128(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt128(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt128(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt128 left, UInt128 right) => !(left == right);
        public static bool operator ==(UInt128 left, UInt128 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt128 left, UInt128 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt128 left, UInt128 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt128 left, UInt128 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt128 left, UInt128 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt128 operator %(UInt128 dividend, UInt128 divisor) => new UInt128(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt128 operator +(UInt128 left, UInt128 right) => new UInt128(left.ToBigInteger() + right.ToBigInteger());
        public static UInt128 operator -(UInt128 left, UInt128 right) => new UInt128(left.ToBigInteger() - right.ToBigInteger());
        public static UInt128 operator *(UInt128 left, UInt128 right) => new UInt128(left.ToBigInteger() * right.ToBigInteger());
        public static UInt128 operator /(UInt128 dividend, UInt128 divisor) => new UInt128(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt128 operator >>(UInt128 value, int shift) => new UInt128(value.ToBigInteger() >> shift);
        public static UInt128 operator <<(UInt128 value, int shift) => new UInt128(value.ToBigInteger() << shift);
        public static UInt128 operator |(UInt128 left, UInt128 right) => new UInt128(left.ToBigInteger() | right.ToBigInteger());
        public static UInt128 operator &(UInt128 left, UInt128 right) => new UInt128(left.ToBigInteger() & right.ToBigInteger());
        public static UInt128 operator ^(UInt128 left, UInt128 right) => new UInt128(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt128 operator ++(UInt128 value) => value + One;
        public static UInt128 operator --(UInt128 value) => value - One;
        public static UInt128 operator ~(UInt128 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt128(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt128 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt128 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt128 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt128 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt128 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt128 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt128 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt128 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt128 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt128 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt128 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt128 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt128(sbyte value) => new UInt128(value);
        public static implicit operator UInt128(byte value) => new UInt128(value);
        public static explicit operator UInt128(short value) => new UInt128(value);
        public static implicit operator UInt128(ushort value) => new UInt128(value);
        public static explicit operator UInt128(int value) => new UInt128(value);
        public static implicit operator UInt128(uint value) => new UInt128(value);
        public static explicit operator UInt128(long value) => new UInt128(value);
        public static implicit operator UInt128(ulong value) => new UInt128(value);
        public static explicit operator UInt128(float value) => FromFloatingType(value);
        public static explicit operator UInt128(double value) => FromFloatingType(value);
        public static explicit operator UInt128(decimal value) => FromDecimalType(value);
        public static explicit operator UInt128(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt128(BigInteger value) => new UInt128(value);

        // Sibling Types -> This Type
        public static explicit operator UInt128(Int24 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int40 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int48 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int56 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int72 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int80 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int88 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int96 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int104 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int112 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int120 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int128 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int136 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int144 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int152 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int160 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int168 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int176 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int184 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int192 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int200 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int208 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int216 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int224 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int232 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int240 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(Int248 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt24 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt40 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt48 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt56 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt72 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt80 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt88 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt96 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt104 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt112 value) => new UInt128(value.ToBigInteger());
        public static implicit operator UInt128(UInt120 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt136 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt144 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt152 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt160 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt168 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt176 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt184 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt192 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt200 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt208 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt216 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt224 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt232 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt240 value) => new UInt128(value.ToBigInteger());
        public static explicit operator UInt128(UInt248 value) => new UInt128(value.ToBigInteger());

        public static UInt128 DivRem(UInt128 dividend, UInt128 divisor, out UInt128 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt128(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt128(remainderBigInt);
            return result;
        }

        public static UInt128 Pow(UInt128 value, int exponent) => new UInt128(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt128 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt128 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt128)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt128)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt128)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt128)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt128)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt128)})");
            }

            return new UInt128(bigInt);
        }

        static UInt128 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt128)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt128)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt128)})");
            }

            return new UInt128(bigInt);
        }

        public static UInt128 Parse(string value, IFormatProvider provider) => new UInt128(BigInteger.Parse("0" + value, provider));
        public static UInt128 Parse(string value, NumberStyles style) => new UInt128(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt128 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt128(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt128 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt128 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt128)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt128(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt128 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt128 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt128)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt128(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt128 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt128 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt128 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt128))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt128)}");
            }

            // Compare the underlying object
            return CompareTo((UInt128)obj);
        }

        public bool Equals(UInt128 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt128 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt128)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt128 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt128>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt128 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt128)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt128>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt128 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt136 : IIntegerBase, IComparable, IComparable<UInt136>, IEquatable<UInt136>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 17;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt136 MaxValue = new UInt136(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt136 MinValue = new UInt136(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt136 Zero = new UInt136(0);
        public static readonly UInt136 One = new UInt136(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt136(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt136(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt136 left, UInt136 right) => !(left == right);
        public static bool operator ==(UInt136 left, UInt136 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt136 left, UInt136 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt136 left, UInt136 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt136 left, UInt136 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt136 left, UInt136 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt136 operator %(UInt136 dividend, UInt136 divisor) => new UInt136(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt136 operator +(UInt136 left, UInt136 right) => new UInt136(left.ToBigInteger() + right.ToBigInteger());
        public static UInt136 operator -(UInt136 left, UInt136 right) => new UInt136(left.ToBigInteger() - right.ToBigInteger());
        public static UInt136 operator *(UInt136 left, UInt136 right) => new UInt136(left.ToBigInteger() * right.ToBigInteger());
        public static UInt136 operator /(UInt136 dividend, UInt136 divisor) => new UInt136(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt136 operator >>(UInt136 value, int shift) => new UInt136(value.ToBigInteger() >> shift);
        public static UInt136 operator <<(UInt136 value, int shift) => new UInt136(value.ToBigInteger() << shift);
        public static UInt136 operator |(UInt136 left, UInt136 right) => new UInt136(left.ToBigInteger() | right.ToBigInteger());
        public static UInt136 operator &(UInt136 left, UInt136 right) => new UInt136(left.ToBigInteger() & right.ToBigInteger());
        public static UInt136 operator ^(UInt136 left, UInt136 right) => new UInt136(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt136 operator ++(UInt136 value) => value + One;
        public static UInt136 operator --(UInt136 value) => value - One;
        public static UInt136 operator ~(UInt136 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt136(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt136 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt136 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt136 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt136 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt136 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt136 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt136 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt136 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt136 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt136 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt136 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt136 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt136(sbyte value) => new UInt136(value);
        public static implicit operator UInt136(byte value) => new UInt136(value);
        public static explicit operator UInt136(short value) => new UInt136(value);
        public static implicit operator UInt136(ushort value) => new UInt136(value);
        public static explicit operator UInt136(int value) => new UInt136(value);
        public static implicit operator UInt136(uint value) => new UInt136(value);
        public static explicit operator UInt136(long value) => new UInt136(value);
        public static implicit operator UInt136(ulong value) => new UInt136(value);
        public static explicit operator UInt136(float value) => FromFloatingType(value);
        public static explicit operator UInt136(double value) => FromFloatingType(value);
        public static explicit operator UInt136(decimal value) => FromDecimalType(value);
        public static explicit operator UInt136(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt136(BigInteger value) => new UInt136(value);

        // Sibling Types -> This Type
        public static explicit operator UInt136(Int24 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int40 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int48 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int56 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int72 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int80 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int88 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int96 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int104 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int112 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int120 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int128 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int136 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int144 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int152 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int160 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int168 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int176 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int184 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int192 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int200 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int208 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int216 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int224 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int232 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int240 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(Int248 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt24 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt40 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt48 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt56 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt72 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt80 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt88 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt96 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt104 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt112 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt120 value) => new UInt136(value.ToBigInteger());
        public static implicit operator UInt136(UInt128 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt144 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt152 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt160 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt168 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt176 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt184 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt192 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt200 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt208 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt216 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt224 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt232 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt240 value) => new UInt136(value.ToBigInteger());
        public static explicit operator UInt136(UInt248 value) => new UInt136(value.ToBigInteger());

        public static UInt136 DivRem(UInt136 dividend, UInt136 divisor, out UInt136 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt136(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt136(remainderBigInt);
            return result;
        }

        public static UInt136 Pow(UInt136 value, int exponent) => new UInt136(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt136 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt136 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt136)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt136)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt136)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt136)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt136)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt136)})");
            }

            return new UInt136(bigInt);
        }

        static UInt136 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt136)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt136)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt136)})");
            }

            return new UInt136(bigInt);
        }

        public static UInt136 Parse(string value, IFormatProvider provider) => new UInt136(BigInteger.Parse("0" + value, provider));
        public static UInt136 Parse(string value, NumberStyles style) => new UInt136(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt136 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt136(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt136 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt136 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt136)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt136(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt136 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt136 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt136)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt136(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt136 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt136 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt136 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt136))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt136)}");
            }

            // Compare the underlying object
            return CompareTo((UInt136)obj);
        }

        public bool Equals(UInt136 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt136 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt136)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt136 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt136>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt136 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt136)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt136>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt136 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt144 : IIntegerBase, IComparable, IComparable<UInt144>, IEquatable<UInt144>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 18;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt144 MaxValue = new UInt144(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt144 MinValue = new UInt144(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt144 Zero = new UInt144(0);
        public static readonly UInt144 One = new UInt144(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt144(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt144(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt144 left, UInt144 right) => !(left == right);
        public static bool operator ==(UInt144 left, UInt144 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt144 left, UInt144 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt144 left, UInt144 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt144 left, UInt144 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt144 left, UInt144 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt144 operator %(UInt144 dividend, UInt144 divisor) => new UInt144(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt144 operator +(UInt144 left, UInt144 right) => new UInt144(left.ToBigInteger() + right.ToBigInteger());
        public static UInt144 operator -(UInt144 left, UInt144 right) => new UInt144(left.ToBigInteger() - right.ToBigInteger());
        public static UInt144 operator *(UInt144 left, UInt144 right) => new UInt144(left.ToBigInteger() * right.ToBigInteger());
        public static UInt144 operator /(UInt144 dividend, UInt144 divisor) => new UInt144(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt144 operator >>(UInt144 value, int shift) => new UInt144(value.ToBigInteger() >> shift);
        public static UInt144 operator <<(UInt144 value, int shift) => new UInt144(value.ToBigInteger() << shift);
        public static UInt144 operator |(UInt144 left, UInt144 right) => new UInt144(left.ToBigInteger() | right.ToBigInteger());
        public static UInt144 operator &(UInt144 left, UInt144 right) => new UInt144(left.ToBigInteger() & right.ToBigInteger());
        public static UInt144 operator ^(UInt144 left, UInt144 right) => new UInt144(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt144 operator ++(UInt144 value) => value + One;
        public static UInt144 operator --(UInt144 value) => value - One;
        public static UInt144 operator ~(UInt144 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt144(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt144 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt144 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt144 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt144 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt144 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt144 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt144 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt144 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt144 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt144 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt144 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt144 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt144(sbyte value) => new UInt144(value);
        public static implicit operator UInt144(byte value) => new UInt144(value);
        public static explicit operator UInt144(short value) => new UInt144(value);
        public static implicit operator UInt144(ushort value) => new UInt144(value);
        public static explicit operator UInt144(int value) => new UInt144(value);
        public static implicit operator UInt144(uint value) => new UInt144(value);
        public static explicit operator UInt144(long value) => new UInt144(value);
        public static implicit operator UInt144(ulong value) => new UInt144(value);
        public static explicit operator UInt144(float value) => FromFloatingType(value);
        public static explicit operator UInt144(double value) => FromFloatingType(value);
        public static explicit operator UInt144(decimal value) => FromDecimalType(value);
        public static explicit operator UInt144(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt144(BigInteger value) => new UInt144(value);

        // Sibling Types -> This Type
        public static explicit operator UInt144(Int24 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int40 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int48 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int56 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int72 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int80 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int88 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int96 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int104 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int112 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int120 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int128 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int136 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int144 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int152 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int160 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int168 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int176 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int184 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int192 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int200 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int208 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int216 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int224 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int232 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int240 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(Int248 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt24 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt40 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt48 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt56 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt72 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt80 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt88 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt96 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt104 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt112 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt120 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt128 value) => new UInt144(value.ToBigInteger());
        public static implicit operator UInt144(UInt136 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt152 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt160 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt168 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt176 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt184 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt192 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt200 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt208 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt216 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt224 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt232 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt240 value) => new UInt144(value.ToBigInteger());
        public static explicit operator UInt144(UInt248 value) => new UInt144(value.ToBigInteger());

        public static UInt144 DivRem(UInt144 dividend, UInt144 divisor, out UInt144 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt144(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt144(remainderBigInt);
            return result;
        }

        public static UInt144 Pow(UInt144 value, int exponent) => new UInt144(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt144 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt144 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt144)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt144)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt144)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt144)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt144)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt144)})");
            }

            return new UInt144(bigInt);
        }

        static UInt144 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt144)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt144)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt144)})");
            }

            return new UInt144(bigInt);
        }

        public static UInt144 Parse(string value, IFormatProvider provider) => new UInt144(BigInteger.Parse("0" + value, provider));
        public static UInt144 Parse(string value, NumberStyles style) => new UInt144(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt144 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt144(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt144 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt144 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt144)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt144(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt144 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt144 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt144)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt144(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt144 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt144 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt144 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt144))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt144)}");
            }

            // Compare the underlying object
            return CompareTo((UInt144)obj);
        }

        public bool Equals(UInt144 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt144 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt144)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt144 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt144>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt144 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt144)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt144>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt144 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt152 : IIntegerBase, IComparable, IComparable<UInt152>, IEquatable<UInt152>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 19;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt152 MaxValue = new UInt152(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt152 MinValue = new UInt152(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt152 Zero = new UInt152(0);
        public static readonly UInt152 One = new UInt152(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt152(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt152(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt152 left, UInt152 right) => !(left == right);
        public static bool operator ==(UInt152 left, UInt152 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt152 left, UInt152 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt152 left, UInt152 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt152 left, UInt152 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt152 left, UInt152 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt152 operator %(UInt152 dividend, UInt152 divisor) => new UInt152(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt152 operator +(UInt152 left, UInt152 right) => new UInt152(left.ToBigInteger() + right.ToBigInteger());
        public static UInt152 operator -(UInt152 left, UInt152 right) => new UInt152(left.ToBigInteger() - right.ToBigInteger());
        public static UInt152 operator *(UInt152 left, UInt152 right) => new UInt152(left.ToBigInteger() * right.ToBigInteger());
        public static UInt152 operator /(UInt152 dividend, UInt152 divisor) => new UInt152(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt152 operator >>(UInt152 value, int shift) => new UInt152(value.ToBigInteger() >> shift);
        public static UInt152 operator <<(UInt152 value, int shift) => new UInt152(value.ToBigInteger() << shift);
        public static UInt152 operator |(UInt152 left, UInt152 right) => new UInt152(left.ToBigInteger() | right.ToBigInteger());
        public static UInt152 operator &(UInt152 left, UInt152 right) => new UInt152(left.ToBigInteger() & right.ToBigInteger());
        public static UInt152 operator ^(UInt152 left, UInt152 right) => new UInt152(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt152 operator ++(UInt152 value) => value + One;
        public static UInt152 operator --(UInt152 value) => value - One;
        public static UInt152 operator ~(UInt152 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt152(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt152 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt152 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt152 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt152 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt152 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt152 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt152 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt152 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt152 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt152 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt152 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt152 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt152(sbyte value) => new UInt152(value);
        public static implicit operator UInt152(byte value) => new UInt152(value);
        public static explicit operator UInt152(short value) => new UInt152(value);
        public static implicit operator UInt152(ushort value) => new UInt152(value);
        public static explicit operator UInt152(int value) => new UInt152(value);
        public static implicit operator UInt152(uint value) => new UInt152(value);
        public static explicit operator UInt152(long value) => new UInt152(value);
        public static implicit operator UInt152(ulong value) => new UInt152(value);
        public static explicit operator UInt152(float value) => FromFloatingType(value);
        public static explicit operator UInt152(double value) => FromFloatingType(value);
        public static explicit operator UInt152(decimal value) => FromDecimalType(value);
        public static explicit operator UInt152(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt152(BigInteger value) => new UInt152(value);

        // Sibling Types -> This Type
        public static explicit operator UInt152(Int24 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int40 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int48 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int56 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int72 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int80 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int88 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int96 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int104 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int112 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int120 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int128 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int136 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int144 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int152 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int160 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int168 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int176 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int184 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int192 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int200 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int208 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int216 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int224 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int232 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int240 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(Int248 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt24 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt40 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt48 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt56 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt72 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt80 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt88 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt96 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt104 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt112 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt120 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt128 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt136 value) => new UInt152(value.ToBigInteger());
        public static implicit operator UInt152(UInt144 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt160 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt168 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt176 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt184 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt192 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt200 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt208 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt216 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt224 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt232 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt240 value) => new UInt152(value.ToBigInteger());
        public static explicit operator UInt152(UInt248 value) => new UInt152(value.ToBigInteger());

        public static UInt152 DivRem(UInt152 dividend, UInt152 divisor, out UInt152 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt152(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt152(remainderBigInt);
            return result;
        }

        public static UInt152 Pow(UInt152 value, int exponent) => new UInt152(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt152 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt152 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt152)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt152)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt152)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt152)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt152)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt152)})");
            }

            return new UInt152(bigInt);
        }

        static UInt152 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt152)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt152)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt152)})");
            }

            return new UInt152(bigInt);
        }

        public static UInt152 Parse(string value, IFormatProvider provider) => new UInt152(BigInteger.Parse("0" + value, provider));
        public static UInt152 Parse(string value, NumberStyles style) => new UInt152(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt152 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt152(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt152 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt152 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt152)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt152(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt152 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt152 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt152)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt152(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt152 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt152 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt152 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt152))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt152)}");
            }

            // Compare the underlying object
            return CompareTo((UInt152)obj);
        }

        public bool Equals(UInt152 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt152 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt152)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt152 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt152>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt152 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt152)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt152>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt152 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt160 : IIntegerBase, IComparable, IComparable<UInt160>, IEquatable<UInt160>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 20;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt160 MaxValue = new UInt160(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt160 MinValue = new UInt160(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt160 Zero = new UInt160(0);
        public static readonly UInt160 One = new UInt160(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt160(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt160(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt160 left, UInt160 right) => !(left == right);
        public static bool operator ==(UInt160 left, UInt160 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt160 left, UInt160 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt160 left, UInt160 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt160 left, UInt160 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt160 left, UInt160 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt160 operator %(UInt160 dividend, UInt160 divisor) => new UInt160(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt160 operator +(UInt160 left, UInt160 right) => new UInt160(left.ToBigInteger() + right.ToBigInteger());
        public static UInt160 operator -(UInt160 left, UInt160 right) => new UInt160(left.ToBigInteger() - right.ToBigInteger());
        public static UInt160 operator *(UInt160 left, UInt160 right) => new UInt160(left.ToBigInteger() * right.ToBigInteger());
        public static UInt160 operator /(UInt160 dividend, UInt160 divisor) => new UInt160(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt160 operator >>(UInt160 value, int shift) => new UInt160(value.ToBigInteger() >> shift);
        public static UInt160 operator <<(UInt160 value, int shift) => new UInt160(value.ToBigInteger() << shift);
        public static UInt160 operator |(UInt160 left, UInt160 right) => new UInt160(left.ToBigInteger() | right.ToBigInteger());
        public static UInt160 operator &(UInt160 left, UInt160 right) => new UInt160(left.ToBigInteger() & right.ToBigInteger());
        public static UInt160 operator ^(UInt160 left, UInt160 right) => new UInt160(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt160 operator ++(UInt160 value) => value + One;
        public static UInt160 operator --(UInt160 value) => value - One;
        public static UInt160 operator ~(UInt160 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt160(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt160 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt160 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt160 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt160 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt160 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt160 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt160 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt160 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt160 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt160 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt160 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt160 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt160(sbyte value) => new UInt160(value);
        public static implicit operator UInt160(byte value) => new UInt160(value);
        public static explicit operator UInt160(short value) => new UInt160(value);
        public static implicit operator UInt160(ushort value) => new UInt160(value);
        public static explicit operator UInt160(int value) => new UInt160(value);
        public static implicit operator UInt160(uint value) => new UInt160(value);
        public static explicit operator UInt160(long value) => new UInt160(value);
        public static implicit operator UInt160(ulong value) => new UInt160(value);
        public static explicit operator UInt160(float value) => FromFloatingType(value);
        public static explicit operator UInt160(double value) => FromFloatingType(value);
        public static explicit operator UInt160(decimal value) => FromDecimalType(value);
        public static explicit operator UInt160(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt160(BigInteger value) => new UInt160(value);

        // Sibling Types -> This Type
        public static explicit operator UInt160(Int24 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int40 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int48 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int56 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int72 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int80 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int88 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int96 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int104 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int112 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int120 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int128 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int136 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int144 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int152 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int160 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int168 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int176 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int184 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int192 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int200 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int208 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int216 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int224 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int232 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int240 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(Int248 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt24 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt40 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt48 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt56 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt72 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt80 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt88 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt96 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt104 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt112 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt120 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt128 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt136 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt144 value) => new UInt160(value.ToBigInteger());
        public static implicit operator UInt160(UInt152 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt168 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt176 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt184 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt192 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt200 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt208 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt216 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt224 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt232 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt240 value) => new UInt160(value.ToBigInteger());
        public static explicit operator UInt160(UInt248 value) => new UInt160(value.ToBigInteger());

        public static UInt160 DivRem(UInt160 dividend, UInt160 divisor, out UInt160 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt160(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt160(remainderBigInt);
            return result;
        }

        public static UInt160 Pow(UInt160 value, int exponent) => new UInt160(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt160 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt160 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt160)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt160)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt160)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt160)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt160)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt160)})");
            }

            return new UInt160(bigInt);
        }

        static UInt160 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt160)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt160)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt160)})");
            }

            return new UInt160(bigInt);
        }

        public static UInt160 Parse(string value, IFormatProvider provider) => new UInt160(BigInteger.Parse("0" + value, provider));
        public static UInt160 Parse(string value, NumberStyles style) => new UInt160(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt160 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt160(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt160 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt160 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt160)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt160(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt160 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt160 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt160)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt160(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt160 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt160 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt160 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt160))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt160)}");
            }

            // Compare the underlying object
            return CompareTo((UInt160)obj);
        }

        public bool Equals(UInt160 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt160 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt160)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt160 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt160>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt160 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt160)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt160>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt160 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt168 : IIntegerBase, IComparable, IComparable<UInt168>, IEquatable<UInt168>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 21;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt168 MaxValue = new UInt168(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt168 MinValue = new UInt168(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt168 Zero = new UInt168(0);
        public static readonly UInt168 One = new UInt168(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt168(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt168(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt168 left, UInt168 right) => !(left == right);
        public static bool operator ==(UInt168 left, UInt168 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt168 left, UInt168 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt168 left, UInt168 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt168 left, UInt168 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt168 left, UInt168 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt168 operator %(UInt168 dividend, UInt168 divisor) => new UInt168(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt168 operator +(UInt168 left, UInt168 right) => new UInt168(left.ToBigInteger() + right.ToBigInteger());
        public static UInt168 operator -(UInt168 left, UInt168 right) => new UInt168(left.ToBigInteger() - right.ToBigInteger());
        public static UInt168 operator *(UInt168 left, UInt168 right) => new UInt168(left.ToBigInteger() * right.ToBigInteger());
        public static UInt168 operator /(UInt168 dividend, UInt168 divisor) => new UInt168(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt168 operator >>(UInt168 value, int shift) => new UInt168(value.ToBigInteger() >> shift);
        public static UInt168 operator <<(UInt168 value, int shift) => new UInt168(value.ToBigInteger() << shift);
        public static UInt168 operator |(UInt168 left, UInt168 right) => new UInt168(left.ToBigInteger() | right.ToBigInteger());
        public static UInt168 operator &(UInt168 left, UInt168 right) => new UInt168(left.ToBigInteger() & right.ToBigInteger());
        public static UInt168 operator ^(UInt168 left, UInt168 right) => new UInt168(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt168 operator ++(UInt168 value) => value + One;
        public static UInt168 operator --(UInt168 value) => value - One;
        public static UInt168 operator ~(UInt168 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt168(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt168 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt168 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt168 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt168 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt168 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt168 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt168 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt168 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt168 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt168 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt168 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt168 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt168(sbyte value) => new UInt168(value);
        public static implicit operator UInt168(byte value) => new UInt168(value);
        public static explicit operator UInt168(short value) => new UInt168(value);
        public static implicit operator UInt168(ushort value) => new UInt168(value);
        public static explicit operator UInt168(int value) => new UInt168(value);
        public static implicit operator UInt168(uint value) => new UInt168(value);
        public static explicit operator UInt168(long value) => new UInt168(value);
        public static implicit operator UInt168(ulong value) => new UInt168(value);
        public static explicit operator UInt168(float value) => FromFloatingType(value);
        public static explicit operator UInt168(double value) => FromFloatingType(value);
        public static explicit operator UInt168(decimal value) => FromDecimalType(value);
        public static explicit operator UInt168(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt168(BigInteger value) => new UInt168(value);

        // Sibling Types -> This Type
        public static explicit operator UInt168(Int24 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int40 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int48 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int56 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int72 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int80 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int88 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int96 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int104 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int112 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int120 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int128 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int136 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int144 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int152 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int160 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int168 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int176 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int184 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int192 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int200 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int208 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int216 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int224 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int232 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int240 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(Int248 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt24 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt40 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt48 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt56 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt72 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt80 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt88 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt96 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt104 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt112 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt120 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt128 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt136 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt144 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt152 value) => new UInt168(value.ToBigInteger());
        public static implicit operator UInt168(UInt160 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(UInt176 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(UInt184 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(UInt192 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(UInt200 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(UInt208 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(UInt216 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(UInt224 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(UInt232 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(UInt240 value) => new UInt168(value.ToBigInteger());
        public static explicit operator UInt168(UInt248 value) => new UInt168(value.ToBigInteger());

        public static UInt168 DivRem(UInt168 dividend, UInt168 divisor, out UInt168 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt168(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt168(remainderBigInt);
            return result;
        }

        public static UInt168 Pow(UInt168 value, int exponent) => new UInt168(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt168 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt168 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt168)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt168)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt168)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt168)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt168)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt168)})");
            }

            return new UInt168(bigInt);
        }

        static UInt168 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt168)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt168)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt168)})");
            }

            return new UInt168(bigInt);
        }

        public static UInt168 Parse(string value, IFormatProvider provider) => new UInt168(BigInteger.Parse("0" + value, provider));
        public static UInt168 Parse(string value, NumberStyles style) => new UInt168(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt168 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt168(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt168 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt168 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt168)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt168(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt168 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt168 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt168)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt168(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt168 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt168 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt168 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt168))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt168)}");
            }

            // Compare the underlying object
            return CompareTo((UInt168)obj);
        }

        public bool Equals(UInt168 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt168 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt168)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt168 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt168>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt168 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt168)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt168>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt168 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt176 : IIntegerBase, IComparable, IComparable<UInt176>, IEquatable<UInt176>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 22;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt176 MaxValue = new UInt176(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt176 MinValue = new UInt176(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt176 Zero = new UInt176(0);
        public static readonly UInt176 One = new UInt176(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt176(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt176(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt176 left, UInt176 right) => !(left == right);
        public static bool operator ==(UInt176 left, UInt176 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt176 left, UInt176 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt176 left, UInt176 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt176 left, UInt176 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt176 left, UInt176 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt176 operator %(UInt176 dividend, UInt176 divisor) => new UInt176(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt176 operator +(UInt176 left, UInt176 right) => new UInt176(left.ToBigInteger() + right.ToBigInteger());
        public static UInt176 operator -(UInt176 left, UInt176 right) => new UInt176(left.ToBigInteger() - right.ToBigInteger());
        public static UInt176 operator *(UInt176 left, UInt176 right) => new UInt176(left.ToBigInteger() * right.ToBigInteger());
        public static UInt176 operator /(UInt176 dividend, UInt176 divisor) => new UInt176(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt176 operator >>(UInt176 value, int shift) => new UInt176(value.ToBigInteger() >> shift);
        public static UInt176 operator <<(UInt176 value, int shift) => new UInt176(value.ToBigInteger() << shift);
        public static UInt176 operator |(UInt176 left, UInt176 right) => new UInt176(left.ToBigInteger() | right.ToBigInteger());
        public static UInt176 operator &(UInt176 left, UInt176 right) => new UInt176(left.ToBigInteger() & right.ToBigInteger());
        public static UInt176 operator ^(UInt176 left, UInt176 right) => new UInt176(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt176 operator ++(UInt176 value) => value + One;
        public static UInt176 operator --(UInt176 value) => value - One;
        public static UInt176 operator ~(UInt176 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt176(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt176 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt176 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt176 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt176 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt176 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt176 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt176 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt176 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt176 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt176 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt176 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt176 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt176(sbyte value) => new UInt176(value);
        public static implicit operator UInt176(byte value) => new UInt176(value);
        public static explicit operator UInt176(short value) => new UInt176(value);
        public static implicit operator UInt176(ushort value) => new UInt176(value);
        public static explicit operator UInt176(int value) => new UInt176(value);
        public static implicit operator UInt176(uint value) => new UInt176(value);
        public static explicit operator UInt176(long value) => new UInt176(value);
        public static implicit operator UInt176(ulong value) => new UInt176(value);
        public static explicit operator UInt176(float value) => FromFloatingType(value);
        public static explicit operator UInt176(double value) => FromFloatingType(value);
        public static explicit operator UInt176(decimal value) => FromDecimalType(value);
        public static explicit operator UInt176(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt176(BigInteger value) => new UInt176(value);

        // Sibling Types -> This Type
        public static explicit operator UInt176(Int24 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int40 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int48 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int56 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int72 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int80 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int88 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int96 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int104 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int112 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int120 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int128 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int136 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int144 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int152 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int160 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int168 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int176 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int184 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int192 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int200 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int208 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int216 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int224 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int232 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int240 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(Int248 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt24 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt40 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt48 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt56 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt72 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt80 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt88 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt96 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt104 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt112 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt120 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt128 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt136 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt144 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt152 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt160 value) => new UInt176(value.ToBigInteger());
        public static implicit operator UInt176(UInt168 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(UInt184 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(UInt192 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(UInt200 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(UInt208 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(UInt216 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(UInt224 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(UInt232 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(UInt240 value) => new UInt176(value.ToBigInteger());
        public static explicit operator UInt176(UInt248 value) => new UInt176(value.ToBigInteger());

        public static UInt176 DivRem(UInt176 dividend, UInt176 divisor, out UInt176 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt176(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt176(remainderBigInt);
            return result;
        }

        public static UInt176 Pow(UInt176 value, int exponent) => new UInt176(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt176 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt176 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt176)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt176)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt176)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt176)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt176)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt176)})");
            }

            return new UInt176(bigInt);
        }

        static UInt176 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt176)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt176)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt176)})");
            }

            return new UInt176(bigInt);
        }

        public static UInt176 Parse(string value, IFormatProvider provider) => new UInt176(BigInteger.Parse("0" + value, provider));
        public static UInt176 Parse(string value, NumberStyles style) => new UInt176(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt176 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt176(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt176 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt176 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt176)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt176(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt176 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt176 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt176)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt176(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt176 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt176 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt176 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt176))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt176)}");
            }

            // Compare the underlying object
            return CompareTo((UInt176)obj);
        }

        public bool Equals(UInt176 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt176 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt176)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt176 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt176>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt176 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt176)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt176>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt176 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt184 : IIntegerBase, IComparable, IComparable<UInt184>, IEquatable<UInt184>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 23;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt184 MaxValue = new UInt184(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt184 MinValue = new UInt184(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt184 Zero = new UInt184(0);
        public static readonly UInt184 One = new UInt184(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt184(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt184(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt184 left, UInt184 right) => !(left == right);
        public static bool operator ==(UInt184 left, UInt184 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt184 left, UInt184 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt184 left, UInt184 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt184 left, UInt184 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt184 left, UInt184 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt184 operator %(UInt184 dividend, UInt184 divisor) => new UInt184(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt184 operator +(UInt184 left, UInt184 right) => new UInt184(left.ToBigInteger() + right.ToBigInteger());
        public static UInt184 operator -(UInt184 left, UInt184 right) => new UInt184(left.ToBigInteger() - right.ToBigInteger());
        public static UInt184 operator *(UInt184 left, UInt184 right) => new UInt184(left.ToBigInteger() * right.ToBigInteger());
        public static UInt184 operator /(UInt184 dividend, UInt184 divisor) => new UInt184(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt184 operator >>(UInt184 value, int shift) => new UInt184(value.ToBigInteger() >> shift);
        public static UInt184 operator <<(UInt184 value, int shift) => new UInt184(value.ToBigInteger() << shift);
        public static UInt184 operator |(UInt184 left, UInt184 right) => new UInt184(left.ToBigInteger() | right.ToBigInteger());
        public static UInt184 operator &(UInt184 left, UInt184 right) => new UInt184(left.ToBigInteger() & right.ToBigInteger());
        public static UInt184 operator ^(UInt184 left, UInt184 right) => new UInt184(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt184 operator ++(UInt184 value) => value + One;
        public static UInt184 operator --(UInt184 value) => value - One;
        public static UInt184 operator ~(UInt184 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt184(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt184 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt184 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt184 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt184 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt184 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt184 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt184 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt184 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt184 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt184 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt184 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt184 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt184(sbyte value) => new UInt184(value);
        public static implicit operator UInt184(byte value) => new UInt184(value);
        public static explicit operator UInt184(short value) => new UInt184(value);
        public static implicit operator UInt184(ushort value) => new UInt184(value);
        public static explicit operator UInt184(int value) => new UInt184(value);
        public static implicit operator UInt184(uint value) => new UInt184(value);
        public static explicit operator UInt184(long value) => new UInt184(value);
        public static implicit operator UInt184(ulong value) => new UInt184(value);
        public static explicit operator UInt184(float value) => FromFloatingType(value);
        public static explicit operator UInt184(double value) => FromFloatingType(value);
        public static explicit operator UInt184(decimal value) => FromDecimalType(value);
        public static explicit operator UInt184(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt184(BigInteger value) => new UInt184(value);

        // Sibling Types -> This Type
        public static explicit operator UInt184(Int24 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int40 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int48 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int56 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int72 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int80 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int88 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int96 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int104 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int112 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int120 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int128 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int136 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int144 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int152 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int160 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int168 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int176 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int184 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int192 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int200 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int208 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int216 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int224 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int232 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int240 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(Int248 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt24 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt40 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt48 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt56 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt72 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt80 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt88 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt96 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt104 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt112 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt120 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt128 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt136 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt144 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt152 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt160 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt168 value) => new UInt184(value.ToBigInteger());
        public static implicit operator UInt184(UInt176 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(UInt192 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(UInt200 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(UInt208 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(UInt216 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(UInt224 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(UInt232 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(UInt240 value) => new UInt184(value.ToBigInteger());
        public static explicit operator UInt184(UInt248 value) => new UInt184(value.ToBigInteger());

        public static UInt184 DivRem(UInt184 dividend, UInt184 divisor, out UInt184 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt184(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt184(remainderBigInt);
            return result;
        }

        public static UInt184 Pow(UInt184 value, int exponent) => new UInt184(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt184 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt184 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt184)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt184)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt184)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt184)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt184)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt184)})");
            }

            return new UInt184(bigInt);
        }

        static UInt184 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt184)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt184)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt184)})");
            }

            return new UInt184(bigInt);
        }

        public static UInt184 Parse(string value, IFormatProvider provider) => new UInt184(BigInteger.Parse("0" + value, provider));
        public static UInt184 Parse(string value, NumberStyles style) => new UInt184(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt184 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt184(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt184 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt184 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt184)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt184(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt184 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt184 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt184)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt184(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt184 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt184 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt184 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt184))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt184)}");
            }

            // Compare the underlying object
            return CompareTo((UInt184)obj);
        }

        public bool Equals(UInt184 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt184 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt184)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt184 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt184>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt184 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt184)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt184>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt184 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt192 : IIntegerBase, IComparable, IComparable<UInt192>, IEquatable<UInt192>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 24;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt192 MaxValue = new UInt192(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt192 MinValue = new UInt192(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt192 Zero = new UInt192(0);
        public static readonly UInt192 One = new UInt192(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt192(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt192(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt192 left, UInt192 right) => !(left == right);
        public static bool operator ==(UInt192 left, UInt192 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt192 left, UInt192 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt192 left, UInt192 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt192 left, UInt192 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt192 left, UInt192 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt192 operator %(UInt192 dividend, UInt192 divisor) => new UInt192(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt192 operator +(UInt192 left, UInt192 right) => new UInt192(left.ToBigInteger() + right.ToBigInteger());
        public static UInt192 operator -(UInt192 left, UInt192 right) => new UInt192(left.ToBigInteger() - right.ToBigInteger());
        public static UInt192 operator *(UInt192 left, UInt192 right) => new UInt192(left.ToBigInteger() * right.ToBigInteger());
        public static UInt192 operator /(UInt192 dividend, UInt192 divisor) => new UInt192(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt192 operator >>(UInt192 value, int shift) => new UInt192(value.ToBigInteger() >> shift);
        public static UInt192 operator <<(UInt192 value, int shift) => new UInt192(value.ToBigInteger() << shift);
        public static UInt192 operator |(UInt192 left, UInt192 right) => new UInt192(left.ToBigInteger() | right.ToBigInteger());
        public static UInt192 operator &(UInt192 left, UInt192 right) => new UInt192(left.ToBigInteger() & right.ToBigInteger());
        public static UInt192 operator ^(UInt192 left, UInt192 right) => new UInt192(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt192 operator ++(UInt192 value) => value + One;
        public static UInt192 operator --(UInt192 value) => value - One;
        public static UInt192 operator ~(UInt192 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt192(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt192 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt192 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt192 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt192 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt192 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt192 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt192 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt192 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt192 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt192 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt192 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt192 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt192(sbyte value) => new UInt192(value);
        public static implicit operator UInt192(byte value) => new UInt192(value);
        public static explicit operator UInt192(short value) => new UInt192(value);
        public static implicit operator UInt192(ushort value) => new UInt192(value);
        public static explicit operator UInt192(int value) => new UInt192(value);
        public static implicit operator UInt192(uint value) => new UInt192(value);
        public static explicit operator UInt192(long value) => new UInt192(value);
        public static implicit operator UInt192(ulong value) => new UInt192(value);
        public static explicit operator UInt192(float value) => FromFloatingType(value);
        public static explicit operator UInt192(double value) => FromFloatingType(value);
        public static explicit operator UInt192(decimal value) => FromDecimalType(value);
        public static explicit operator UInt192(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt192(BigInteger value) => new UInt192(value);

        // Sibling Types -> This Type
        public static explicit operator UInt192(Int24 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int40 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int48 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int56 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int72 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int80 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int88 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int96 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int104 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int112 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int120 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int128 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int136 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int144 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int152 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int160 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int168 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int176 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int184 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int192 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int200 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int208 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int216 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int224 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int232 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int240 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(Int248 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt24 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt40 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt48 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt56 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt72 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt80 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt88 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt96 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt104 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt112 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt120 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt128 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt136 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt144 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt152 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt160 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt168 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt176 value) => new UInt192(value.ToBigInteger());
        public static implicit operator UInt192(UInt184 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(UInt200 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(UInt208 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(UInt216 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(UInt224 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(UInt232 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(UInt240 value) => new UInt192(value.ToBigInteger());
        public static explicit operator UInt192(UInt248 value) => new UInt192(value.ToBigInteger());

        public static UInt192 DivRem(UInt192 dividend, UInt192 divisor, out UInt192 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt192(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt192(remainderBigInt);
            return result;
        }

        public static UInt192 Pow(UInt192 value, int exponent) => new UInt192(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt192 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt192 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt192)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt192)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt192)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt192)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt192)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt192)})");
            }

            return new UInt192(bigInt);
        }

        static UInt192 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt192)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt192)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt192)})");
            }

            return new UInt192(bigInt);
        }

        public static UInt192 Parse(string value, IFormatProvider provider) => new UInt192(BigInteger.Parse("0" + value, provider));
        public static UInt192 Parse(string value, NumberStyles style) => new UInt192(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt192 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt192(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt192 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt192 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt192)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt192(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt192 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt192 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt192)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt192(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt192 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt192 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt192 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt192))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt192)}");
            }

            // Compare the underlying object
            return CompareTo((UInt192)obj);
        }

        public bool Equals(UInt192 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt192 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt192)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt192 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt192>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt192 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt192)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt192>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt192 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt200 : IIntegerBase, IComparable, IComparable<UInt200>, IEquatable<UInt200>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 25;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt200 MaxValue = new UInt200(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt200 MinValue = new UInt200(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt200 Zero = new UInt200(0);
        public static readonly UInt200 One = new UInt200(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt200(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt200(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt200 left, UInt200 right) => !(left == right);
        public static bool operator ==(UInt200 left, UInt200 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt200 left, UInt200 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt200 left, UInt200 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt200 left, UInt200 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt200 left, UInt200 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt200 operator %(UInt200 dividend, UInt200 divisor) => new UInt200(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt200 operator +(UInt200 left, UInt200 right) => new UInt200(left.ToBigInteger() + right.ToBigInteger());
        public static UInt200 operator -(UInt200 left, UInt200 right) => new UInt200(left.ToBigInteger() - right.ToBigInteger());
        public static UInt200 operator *(UInt200 left, UInt200 right) => new UInt200(left.ToBigInteger() * right.ToBigInteger());
        public static UInt200 operator /(UInt200 dividend, UInt200 divisor) => new UInt200(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt200 operator >>(UInt200 value, int shift) => new UInt200(value.ToBigInteger() >> shift);
        public static UInt200 operator <<(UInt200 value, int shift) => new UInt200(value.ToBigInteger() << shift);
        public static UInt200 operator |(UInt200 left, UInt200 right) => new UInt200(left.ToBigInteger() | right.ToBigInteger());
        public static UInt200 operator &(UInt200 left, UInt200 right) => new UInt200(left.ToBigInteger() & right.ToBigInteger());
        public static UInt200 operator ^(UInt200 left, UInt200 right) => new UInt200(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt200 operator ++(UInt200 value) => value + One;
        public static UInt200 operator --(UInt200 value) => value - One;
        public static UInt200 operator ~(UInt200 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt200(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt200 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt200 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt200 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt200 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt200 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt200 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt200 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt200 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt200 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt200 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt200 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt200 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt200(sbyte value) => new UInt200(value);
        public static implicit operator UInt200(byte value) => new UInt200(value);
        public static explicit operator UInt200(short value) => new UInt200(value);
        public static implicit operator UInt200(ushort value) => new UInt200(value);
        public static explicit operator UInt200(int value) => new UInt200(value);
        public static implicit operator UInt200(uint value) => new UInt200(value);
        public static explicit operator UInt200(long value) => new UInt200(value);
        public static implicit operator UInt200(ulong value) => new UInt200(value);
        public static explicit operator UInt200(float value) => FromFloatingType(value);
        public static explicit operator UInt200(double value) => FromFloatingType(value);
        public static explicit operator UInt200(decimal value) => FromDecimalType(value);
        public static explicit operator UInt200(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt200(BigInteger value) => new UInt200(value);

        // Sibling Types -> This Type
        public static explicit operator UInt200(Int24 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int40 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int48 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int56 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int72 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int80 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int88 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int96 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int104 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int112 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int120 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int128 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int136 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int144 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int152 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int160 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int168 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int176 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int184 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int192 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int200 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int208 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int216 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int224 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int232 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int240 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(Int248 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt24 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt40 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt48 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt56 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt72 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt80 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt88 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt96 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt104 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt112 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt120 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt128 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt136 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt144 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt152 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt160 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt168 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt176 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt184 value) => new UInt200(value.ToBigInteger());
        public static implicit operator UInt200(UInt192 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(UInt208 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(UInt216 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(UInt224 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(UInt232 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(UInt240 value) => new UInt200(value.ToBigInteger());
        public static explicit operator UInt200(UInt248 value) => new UInt200(value.ToBigInteger());

        public static UInt200 DivRem(UInt200 dividend, UInt200 divisor, out UInt200 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt200(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt200(remainderBigInt);
            return result;
        }

        public static UInt200 Pow(UInt200 value, int exponent) => new UInt200(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt200 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt200 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt200)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt200)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt200)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt200)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt200)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt200)})");
            }

            return new UInt200(bigInt);
        }

        static UInt200 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt200)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt200)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt200)})");
            }

            return new UInt200(bigInt);
        }

        public static UInt200 Parse(string value, IFormatProvider provider) => new UInt200(BigInteger.Parse("0" + value, provider));
        public static UInt200 Parse(string value, NumberStyles style) => new UInt200(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt200 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt200(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt200 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt200 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt200)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt200(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt200 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt200 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt200)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt200(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt200 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt200 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt200 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt200))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt200)}");
            }

            // Compare the underlying object
            return CompareTo((UInt200)obj);
        }

        public bool Equals(UInt200 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt200 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt200)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt200 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt200>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt200 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt200)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt200>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt200 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt208 : IIntegerBase, IComparable, IComparable<UInt208>, IEquatable<UInt208>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 26;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt208 MaxValue = new UInt208(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt208 MinValue = new UInt208(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt208 Zero = new UInt208(0);
        public static readonly UInt208 One = new UInt208(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt208(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt208(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt208 left, UInt208 right) => !(left == right);
        public static bool operator ==(UInt208 left, UInt208 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt208 left, UInt208 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt208 left, UInt208 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt208 left, UInt208 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt208 left, UInt208 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt208 operator %(UInt208 dividend, UInt208 divisor) => new UInt208(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt208 operator +(UInt208 left, UInt208 right) => new UInt208(left.ToBigInteger() + right.ToBigInteger());
        public static UInt208 operator -(UInt208 left, UInt208 right) => new UInt208(left.ToBigInteger() - right.ToBigInteger());
        public static UInt208 operator *(UInt208 left, UInt208 right) => new UInt208(left.ToBigInteger() * right.ToBigInteger());
        public static UInt208 operator /(UInt208 dividend, UInt208 divisor) => new UInt208(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt208 operator >>(UInt208 value, int shift) => new UInt208(value.ToBigInteger() >> shift);
        public static UInt208 operator <<(UInt208 value, int shift) => new UInt208(value.ToBigInteger() << shift);
        public static UInt208 operator |(UInt208 left, UInt208 right) => new UInt208(left.ToBigInteger() | right.ToBigInteger());
        public static UInt208 operator &(UInt208 left, UInt208 right) => new UInt208(left.ToBigInteger() & right.ToBigInteger());
        public static UInt208 operator ^(UInt208 left, UInt208 right) => new UInt208(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt208 operator ++(UInt208 value) => value + One;
        public static UInt208 operator --(UInt208 value) => value - One;
        public static UInt208 operator ~(UInt208 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt208(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt208 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt208 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt208 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt208 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt208 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt208 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt208 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt208 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt208 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt208 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt208 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt208 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt208(sbyte value) => new UInt208(value);
        public static implicit operator UInt208(byte value) => new UInt208(value);
        public static explicit operator UInt208(short value) => new UInt208(value);
        public static implicit operator UInt208(ushort value) => new UInt208(value);
        public static explicit operator UInt208(int value) => new UInt208(value);
        public static implicit operator UInt208(uint value) => new UInt208(value);
        public static explicit operator UInt208(long value) => new UInt208(value);
        public static implicit operator UInt208(ulong value) => new UInt208(value);
        public static explicit operator UInt208(float value) => FromFloatingType(value);
        public static explicit operator UInt208(double value) => FromFloatingType(value);
        public static explicit operator UInt208(decimal value) => FromDecimalType(value);
        public static explicit operator UInt208(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt208(BigInteger value) => new UInt208(value);

        // Sibling Types -> This Type
        public static explicit operator UInt208(Int24 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int40 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int48 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int56 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int72 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int80 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int88 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int96 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int104 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int112 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int120 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int128 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int136 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int144 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int152 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int160 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int168 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int176 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int184 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int192 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int200 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int208 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int216 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int224 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int232 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int240 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(Int248 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt24 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt40 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt48 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt56 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt72 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt80 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt88 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt96 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt104 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt112 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt120 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt128 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt136 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt144 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt152 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt160 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt168 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt176 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt184 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt192 value) => new UInt208(value.ToBigInteger());
        public static implicit operator UInt208(UInt200 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(UInt216 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(UInt224 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(UInt232 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(UInt240 value) => new UInt208(value.ToBigInteger());
        public static explicit operator UInt208(UInt248 value) => new UInt208(value.ToBigInteger());

        public static UInt208 DivRem(UInt208 dividend, UInt208 divisor, out UInt208 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt208(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt208(remainderBigInt);
            return result;
        }

        public static UInt208 Pow(UInt208 value, int exponent) => new UInt208(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt208 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt208 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt208)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt208)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt208)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt208)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt208)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt208)})");
            }

            return new UInt208(bigInt);
        }

        static UInt208 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt208)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt208)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt208)})");
            }

            return new UInt208(bigInt);
        }

        public static UInt208 Parse(string value, IFormatProvider provider) => new UInt208(BigInteger.Parse("0" + value, provider));
        public static UInt208 Parse(string value, NumberStyles style) => new UInt208(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt208 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt208(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt208 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt208 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt208)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt208(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt208 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt208 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt208)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt208(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt208 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt208 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt208 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt208))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt208)}");
            }

            // Compare the underlying object
            return CompareTo((UInt208)obj);
        }

        public bool Equals(UInt208 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt208 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt208)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt208 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt208>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt208 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt208)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt208>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt208 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt216 : IIntegerBase, IComparable, IComparable<UInt216>, IEquatable<UInt216>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 27;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt216 MaxValue = new UInt216(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt216 MinValue = new UInt216(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt216 Zero = new UInt216(0);
        public static readonly UInt216 One = new UInt216(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        private readonly byte _b26;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt216(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt216(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt216 left, UInt216 right) => !(left == right);
        public static bool operator ==(UInt216 left, UInt216 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt216 left, UInt216 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt216 left, UInt216 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt216 left, UInt216 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt216 left, UInt216 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt216 operator %(UInt216 dividend, UInt216 divisor) => new UInt216(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt216 operator +(UInt216 left, UInt216 right) => new UInt216(left.ToBigInteger() + right.ToBigInteger());
        public static UInt216 operator -(UInt216 left, UInt216 right) => new UInt216(left.ToBigInteger() - right.ToBigInteger());
        public static UInt216 operator *(UInt216 left, UInt216 right) => new UInt216(left.ToBigInteger() * right.ToBigInteger());
        public static UInt216 operator /(UInt216 dividend, UInt216 divisor) => new UInt216(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt216 operator >>(UInt216 value, int shift) => new UInt216(value.ToBigInteger() >> shift);
        public static UInt216 operator <<(UInt216 value, int shift) => new UInt216(value.ToBigInteger() << shift);
        public static UInt216 operator |(UInt216 left, UInt216 right) => new UInt216(left.ToBigInteger() | right.ToBigInteger());
        public static UInt216 operator &(UInt216 left, UInt216 right) => new UInt216(left.ToBigInteger() & right.ToBigInteger());
        public static UInt216 operator ^(UInt216 left, UInt216 right) => new UInt216(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt216 operator ++(UInt216 value) => value + One;
        public static UInt216 operator --(UInt216 value) => value - One;
        public static UInt216 operator ~(UInt216 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt216(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt216 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt216 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt216 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt216 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt216 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt216 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt216 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt216 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt216 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt216 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt216 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt216 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt216(sbyte value) => new UInt216(value);
        public static implicit operator UInt216(byte value) => new UInt216(value);
        public static explicit operator UInt216(short value) => new UInt216(value);
        public static implicit operator UInt216(ushort value) => new UInt216(value);
        public static explicit operator UInt216(int value) => new UInt216(value);
        public static implicit operator UInt216(uint value) => new UInt216(value);
        public static explicit operator UInt216(long value) => new UInt216(value);
        public static implicit operator UInt216(ulong value) => new UInt216(value);
        public static explicit operator UInt216(float value) => FromFloatingType(value);
        public static explicit operator UInt216(double value) => FromFloatingType(value);
        public static explicit operator UInt216(decimal value) => FromDecimalType(value);
        public static explicit operator UInt216(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt216(BigInteger value) => new UInt216(value);

        // Sibling Types -> This Type
        public static explicit operator UInt216(Int24 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int40 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int48 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int56 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int72 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int80 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int88 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int96 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int104 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int112 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int120 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int128 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int136 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int144 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int152 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int160 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int168 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int176 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int184 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int192 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int200 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int208 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int216 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int224 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int232 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int240 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(Int248 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt24 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt40 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt48 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt56 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt72 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt80 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt88 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt96 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt104 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt112 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt120 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt128 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt136 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt144 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt152 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt160 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt168 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt176 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt184 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt192 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt200 value) => new UInt216(value.ToBigInteger());
        public static implicit operator UInt216(UInt208 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(UInt224 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(UInt232 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(UInt240 value) => new UInt216(value.ToBigInteger());
        public static explicit operator UInt216(UInt248 value) => new UInt216(value.ToBigInteger());

        public static UInt216 DivRem(UInt216 dividend, UInt216 divisor, out UInt216 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt216(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt216(remainderBigInt);
            return result;
        }

        public static UInt216 Pow(UInt216 value, int exponent) => new UInt216(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt216 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt216 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt216)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt216)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt216)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt216)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt216)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt216)})");
            }

            return new UInt216(bigInt);
        }

        static UInt216 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt216)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt216)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt216)})");
            }

            return new UInt216(bigInt);
        }

        public static UInt216 Parse(string value, IFormatProvider provider) => new UInt216(BigInteger.Parse("0" + value, provider));
        public static UInt216 Parse(string value, NumberStyles style) => new UInt216(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt216 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt216(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt216 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt216 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt216)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt216(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt216 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt216 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt216)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt216(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt216 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt216 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt216 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt216))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt216)}");
            }

            // Compare the underlying object
            return CompareTo((UInt216)obj);
        }

        public bool Equals(UInt216 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt216 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt216)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25, _b26).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt216 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt216>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt216 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt216)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt216>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt216 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt224 : IIntegerBase, IComparable, IComparable<UInt224>, IEquatable<UInt224>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 28;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt224 MaxValue = new UInt224(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt224 MinValue = new UInt224(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt224 Zero = new UInt224(0);
        public static readonly UInt224 One = new UInt224(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        private readonly byte _b26;
        private readonly byte _b27;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt224(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt224(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt224 left, UInt224 right) => !(left == right);
        public static bool operator ==(UInt224 left, UInt224 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt224 left, UInt224 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt224 left, UInt224 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt224 left, UInt224 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt224 left, UInt224 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt224 operator %(UInt224 dividend, UInt224 divisor) => new UInt224(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt224 operator +(UInt224 left, UInt224 right) => new UInt224(left.ToBigInteger() + right.ToBigInteger());
        public static UInt224 operator -(UInt224 left, UInt224 right) => new UInt224(left.ToBigInteger() - right.ToBigInteger());
        public static UInt224 operator *(UInt224 left, UInt224 right) => new UInt224(left.ToBigInteger() * right.ToBigInteger());
        public static UInt224 operator /(UInt224 dividend, UInt224 divisor) => new UInt224(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt224 operator >>(UInt224 value, int shift) => new UInt224(value.ToBigInteger() >> shift);
        public static UInt224 operator <<(UInt224 value, int shift) => new UInt224(value.ToBigInteger() << shift);
        public static UInt224 operator |(UInt224 left, UInt224 right) => new UInt224(left.ToBigInteger() | right.ToBigInteger());
        public static UInt224 operator &(UInt224 left, UInt224 right) => new UInt224(left.ToBigInteger() & right.ToBigInteger());
        public static UInt224 operator ^(UInt224 left, UInt224 right) => new UInt224(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt224 operator ++(UInt224 value) => value + One;
        public static UInt224 operator --(UInt224 value) => value - One;
        public static UInt224 operator ~(UInt224 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt224(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt224 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt224 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt224 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt224 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt224 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt224 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt224 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt224 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt224 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt224 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt224 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt224 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt224(sbyte value) => new UInt224(value);
        public static implicit operator UInt224(byte value) => new UInt224(value);
        public static explicit operator UInt224(short value) => new UInt224(value);
        public static implicit operator UInt224(ushort value) => new UInt224(value);
        public static explicit operator UInt224(int value) => new UInt224(value);
        public static implicit operator UInt224(uint value) => new UInt224(value);
        public static explicit operator UInt224(long value) => new UInt224(value);
        public static implicit operator UInt224(ulong value) => new UInt224(value);
        public static explicit operator UInt224(float value) => FromFloatingType(value);
        public static explicit operator UInt224(double value) => FromFloatingType(value);
        public static explicit operator UInt224(decimal value) => FromDecimalType(value);
        public static explicit operator UInt224(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt224(BigInteger value) => new UInt224(value);

        // Sibling Types -> This Type
        public static explicit operator UInt224(Int24 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int40 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int48 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int56 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int72 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int80 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int88 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int96 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int104 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int112 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int120 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int128 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int136 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int144 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int152 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int160 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int168 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int176 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int184 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int192 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int200 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int208 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int216 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int224 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int232 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int240 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(Int248 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt24 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt40 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt48 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt56 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt72 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt80 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt88 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt96 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt104 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt112 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt120 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt128 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt136 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt144 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt152 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt160 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt168 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt176 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt184 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt192 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt200 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt208 value) => new UInt224(value.ToBigInteger());
        public static implicit operator UInt224(UInt216 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(UInt232 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(UInt240 value) => new UInt224(value.ToBigInteger());
        public static explicit operator UInt224(UInt248 value) => new UInt224(value.ToBigInteger());

        public static UInt224 DivRem(UInt224 dividend, UInt224 divisor, out UInt224 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt224(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt224(remainderBigInt);
            return result;
        }

        public static UInt224 Pow(UInt224 value, int exponent) => new UInt224(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt224 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt224 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt224)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt224)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt224)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt224)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt224)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt224)})");
            }

            return new UInt224(bigInt);
        }

        static UInt224 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt224)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt224)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt224)})");
            }

            return new UInt224(bigInt);
        }

        public static UInt224 Parse(string value, IFormatProvider provider) => new UInt224(BigInteger.Parse("0" + value, provider));
        public static UInt224 Parse(string value, NumberStyles style) => new UInt224(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt224 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt224(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt224 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt224 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt224)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt224(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt224 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt224 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt224)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt224(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt224 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt224 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt224 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt224))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt224)}");
            }

            // Compare the underlying object
            return CompareTo((UInt224)obj);
        }

        public bool Equals(UInt224 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt224 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt224)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25, _b26, _b27).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt224 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt224>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt224 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt224)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt224>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt224 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt232 : IIntegerBase, IComparable, IComparable<UInt232>, IEquatable<UInt232>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 29;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt232 MaxValue = new UInt232(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt232 MinValue = new UInt232(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt232 Zero = new UInt232(0);
        public static readonly UInt232 One = new UInt232(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        private readonly byte _b26;
        private readonly byte _b27;
        private readonly byte _b28;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt232(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt232(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt232 left, UInt232 right) => !(left == right);
        public static bool operator ==(UInt232 left, UInt232 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt232 left, UInt232 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt232 left, UInt232 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt232 left, UInt232 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt232 left, UInt232 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt232 operator %(UInt232 dividend, UInt232 divisor) => new UInt232(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt232 operator +(UInt232 left, UInt232 right) => new UInt232(left.ToBigInteger() + right.ToBigInteger());
        public static UInt232 operator -(UInt232 left, UInt232 right) => new UInt232(left.ToBigInteger() - right.ToBigInteger());
        public static UInt232 operator *(UInt232 left, UInt232 right) => new UInt232(left.ToBigInteger() * right.ToBigInteger());
        public static UInt232 operator /(UInt232 dividend, UInt232 divisor) => new UInt232(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt232 operator >>(UInt232 value, int shift) => new UInt232(value.ToBigInteger() >> shift);
        public static UInt232 operator <<(UInt232 value, int shift) => new UInt232(value.ToBigInteger() << shift);
        public static UInt232 operator |(UInt232 left, UInt232 right) => new UInt232(left.ToBigInteger() | right.ToBigInteger());
        public static UInt232 operator &(UInt232 left, UInt232 right) => new UInt232(left.ToBigInteger() & right.ToBigInteger());
        public static UInt232 operator ^(UInt232 left, UInt232 right) => new UInt232(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt232 operator ++(UInt232 value) => value + One;
        public static UInt232 operator --(UInt232 value) => value - One;
        public static UInt232 operator ~(UInt232 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt232(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt232 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt232 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt232 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt232 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt232 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt232 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt232 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt232 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt232 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt232 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt232 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt232 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt232(sbyte value) => new UInt232(value);
        public static implicit operator UInt232(byte value) => new UInt232(value);
        public static explicit operator UInt232(short value) => new UInt232(value);
        public static implicit operator UInt232(ushort value) => new UInt232(value);
        public static explicit operator UInt232(int value) => new UInt232(value);
        public static implicit operator UInt232(uint value) => new UInt232(value);
        public static explicit operator UInt232(long value) => new UInt232(value);
        public static implicit operator UInt232(ulong value) => new UInt232(value);
        public static explicit operator UInt232(float value) => FromFloatingType(value);
        public static explicit operator UInt232(double value) => FromFloatingType(value);
        public static explicit operator UInt232(decimal value) => FromDecimalType(value);
        public static explicit operator UInt232(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt232(BigInteger value) => new UInt232(value);

        // Sibling Types -> This Type
        public static explicit operator UInt232(Int24 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int40 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int48 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int56 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int72 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int80 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int88 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int96 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int104 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int112 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int120 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int128 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int136 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int144 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int152 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int160 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int168 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int176 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int184 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int192 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int200 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int208 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int216 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int224 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int232 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int240 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(Int248 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt24 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt40 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt48 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt56 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt72 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt80 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt88 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt96 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt104 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt112 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt120 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt128 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt136 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt144 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt152 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt160 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt168 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt176 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt184 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt192 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt200 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt208 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt216 value) => new UInt232(value.ToBigInteger());
        public static implicit operator UInt232(UInt224 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(UInt240 value) => new UInt232(value.ToBigInteger());
        public static explicit operator UInt232(UInt248 value) => new UInt232(value.ToBigInteger());

        public static UInt232 DivRem(UInt232 dividend, UInt232 divisor, out UInt232 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt232(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt232(remainderBigInt);
            return result;
        }

        public static UInt232 Pow(UInt232 value, int exponent) => new UInt232(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt232 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt232 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt232)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt232)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt232)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt232)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt232)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt232)})");
            }

            return new UInt232(bigInt);
        }

        static UInt232 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt232)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt232)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt232)})");
            }

            return new UInt232(bigInt);
        }

        public static UInt232 Parse(string value, IFormatProvider provider) => new UInt232(BigInteger.Parse("0" + value, provider));
        public static UInt232 Parse(string value, NumberStyles style) => new UInt232(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt232 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt232(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt232 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt232 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt232)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt232(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt232 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt232 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt232)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt232(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt232 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt232 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt232 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt232))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt232)}");
            }

            // Compare the underlying object
            return CompareTo((UInt232)obj);
        }

        public bool Equals(UInt232 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt232 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt232)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25, _b26, _b27, _b28).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt232 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt232>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt232 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt232)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt232>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt232 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt240 : IIntegerBase, IComparable, IComparable<UInt240>, IEquatable<UInt240>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 30;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt240 MaxValue = new UInt240(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt240 MinValue = new UInt240(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt240 Zero = new UInt240(0);
        public static readonly UInt240 One = new UInt240(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        private readonly byte _b26;
        private readonly byte _b27;
        private readonly byte _b28;
        private readonly byte _b29;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt240(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt240(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt240 left, UInt240 right) => !(left == right);
        public static bool operator ==(UInt240 left, UInt240 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt240 left, UInt240 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt240 left, UInt240 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt240 left, UInt240 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt240 left, UInt240 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt240 operator %(UInt240 dividend, UInt240 divisor) => new UInt240(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt240 operator +(UInt240 left, UInt240 right) => new UInt240(left.ToBigInteger() + right.ToBigInteger());
        public static UInt240 operator -(UInt240 left, UInt240 right) => new UInt240(left.ToBigInteger() - right.ToBigInteger());
        public static UInt240 operator *(UInt240 left, UInt240 right) => new UInt240(left.ToBigInteger() * right.ToBigInteger());
        public static UInt240 operator /(UInt240 dividend, UInt240 divisor) => new UInt240(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt240 operator >>(UInt240 value, int shift) => new UInt240(value.ToBigInteger() >> shift);
        public static UInt240 operator <<(UInt240 value, int shift) => new UInt240(value.ToBigInteger() << shift);
        public static UInt240 operator |(UInt240 left, UInt240 right) => new UInt240(left.ToBigInteger() | right.ToBigInteger());
        public static UInt240 operator &(UInt240 left, UInt240 right) => new UInt240(left.ToBigInteger() & right.ToBigInteger());
        public static UInt240 operator ^(UInt240 left, UInt240 right) => new UInt240(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt240 operator ++(UInt240 value) => value + One;
        public static UInt240 operator --(UInt240 value) => value - One;
        public static UInt240 operator ~(UInt240 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt240(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt240 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt240 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt240 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt240 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt240 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt240 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt240 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt240 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt240 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt240 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt240 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt240 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt240(sbyte value) => new UInt240(value);
        public static implicit operator UInt240(byte value) => new UInt240(value);
        public static explicit operator UInt240(short value) => new UInt240(value);
        public static implicit operator UInt240(ushort value) => new UInt240(value);
        public static explicit operator UInt240(int value) => new UInt240(value);
        public static implicit operator UInt240(uint value) => new UInt240(value);
        public static explicit operator UInt240(long value) => new UInt240(value);
        public static implicit operator UInt240(ulong value) => new UInt240(value);
        public static explicit operator UInt240(float value) => FromFloatingType(value);
        public static explicit operator UInt240(double value) => FromFloatingType(value);
        public static explicit operator UInt240(decimal value) => FromDecimalType(value);
        public static explicit operator UInt240(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt240(BigInteger value) => new UInt240(value);

        // Sibling Types -> This Type
        public static explicit operator UInt240(Int24 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int40 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int48 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int56 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int72 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int80 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int88 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int96 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int104 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int112 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int120 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int128 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int136 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int144 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int152 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int160 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int168 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int176 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int184 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int192 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int200 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int208 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int216 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int224 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int232 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int240 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(Int248 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt24 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt40 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt48 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt56 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt72 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt80 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt88 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt96 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt104 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt112 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt120 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt128 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt136 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt144 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt152 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt160 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt168 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt176 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt184 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt192 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt200 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt208 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt216 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt224 value) => new UInt240(value.ToBigInteger());
        public static implicit operator UInt240(UInt232 value) => new UInt240(value.ToBigInteger());
        public static explicit operator UInt240(UInt248 value) => new UInt240(value.ToBigInteger());

        public static UInt240 DivRem(UInt240 dividend, UInt240 divisor, out UInt240 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt240(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt240(remainderBigInt);
            return result;
        }

        public static UInt240 Pow(UInt240 value, int exponent) => new UInt240(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt240 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt240 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt240)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt240)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt240)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt240)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt240)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt240)})");
            }

            return new UInt240(bigInt);
        }

        static UInt240 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt240)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt240)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt240)})");
            }

            return new UInt240(bigInt);
        }

        public static UInt240 Parse(string value, IFormatProvider provider) => new UInt240(BigInteger.Parse("0" + value, provider));
        public static UInt240 Parse(string value, NumberStyles style) => new UInt240(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt240 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt240(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt240 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt240 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt240)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt240(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt240 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt240 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt240)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt240(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt240 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt240 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt240 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt240))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt240)}");
            }

            // Compare the underlying object
            return CompareTo((UInt240)obj);
        }

        public bool Equals(UInt240 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt240 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt240)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25, _b26, _b27, _b28, _b29).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt240 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt240>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt240 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt240)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt240>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt240 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    /// <summary>
    /// Represents a fixed size integer and implements its underlying operations.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct UInt248 : IIntegerBase, IComparable, IComparable<UInt248>, IEquatable<UInt248>
    {
        #region Constants
        public const bool SIGNED = false;
        public const int SIZE = 31;
        #endregion

        #region Fields
        private static readonly BigInteger MaskValue = ((BigInteger.One << (SIZE * 8)) - 1);
        public static readonly UInt248 MaxValue = new UInt248(SIGNED ? (MaskValue / 2) : MaskValue);
        public static readonly UInt248 MinValue = new UInt248(SIGNED ? -(MaskValue / 2) - 1 : 0);
        public static readonly UInt248 Zero = new UInt248(0);
        public static readonly UInt248 One = new UInt248(1);

        // Underlying values
        private readonly byte _b0;
        private readonly byte _b1;
        private readonly byte _b2;
        private readonly byte _b3;
        private readonly byte _b4;
        private readonly byte _b5;
        private readonly byte _b6;
        private readonly byte _b7;
        private readonly byte _b8;
        private readonly byte _b9;
        private readonly byte _b10;
        private readonly byte _b11;
        private readonly byte _b12;
        private readonly byte _b13;
        private readonly byte _b14;
        private readonly byte _b15;
        private readonly byte _b16;
        private readonly byte _b17;
        private readonly byte _b18;
        private readonly byte _b19;
        private readonly byte _b20;
        private readonly byte _b21;
        private readonly byte _b22;
        private readonly byte _b23;
        private readonly byte _b24;
        private readonly byte _b25;
        private readonly byte _b26;
        private readonly byte _b27;
        private readonly byte _b28;
        private readonly byte _b29;
        private readonly byte _b30;
        #endregion

        #region Properties
        public bool Signed => SIGNED;
        public int Size => SIZE;
        #endregion

        #region Constructors
        public UInt248(BigInteger value) : this()
        {
            // Obtain our data
            Span<byte> data = BigIntegerConverter.GetBytes(value, SIZE);
            data.Reverse();

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }

        public UInt248(Span<byte> data, bool littleEndian = true) : this()
        {
            // If it's not the correct size, or needs to be endian flipped.
            if (data.Length < SIZE || !littleEndian)
            {
                // Create a new array with our target size.
                Span<byte> newArray = new byte[SIZE];

                // Copy what data we have to it.
                int copySize = Math.Min(data.Length, SIZE);

                // If we are to flip our endianness..
                if (!littleEndian)
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray.Slice(newArray.Length - copySize));

                    // Flip the endianness
                    newArray.Reverse();
                }
                else
                {
                    // Copy our data over
                    data.Slice(0, copySize).CopyTo(newArray);
                }

                // Set the input array as our new array.
                data = newArray;
            }

            // Set our internal value
            var pos = 0;
            FromByteArray(data, ref pos, ref this);
        }
        #endregion

        #region Operators
        // Comparison Operators
        public static bool operator !=(UInt248 left, UInt248 right) => !(left == right);
        public static bool operator ==(UInt248 left, UInt248 right) => left.ToBigInteger() == right.ToBigInteger();
        public static bool operator >(UInt248 left, UInt248 right) => left.ToBigInteger() > right.ToBigInteger();
        public static bool operator >=(UInt248 left, UInt248 right) => left.ToBigInteger() >= right.ToBigInteger();
        public static bool operator <(UInt248 left, UInt248 right) => left.ToBigInteger() < right.ToBigInteger();
        public static bool operator <=(UInt248 left, UInt248 right) => left.ToBigInteger() <= right.ToBigInteger();

        // Arithmetic/Computation Operators
        public static UInt248 operator %(UInt248 dividend, UInt248 divisor) => new UInt248(dividend.ToBigInteger() % divisor.ToBigInteger());
        public static UInt248 operator +(UInt248 left, UInt248 right) => new UInt248(left.ToBigInteger() + right.ToBigInteger());
        public static UInt248 operator -(UInt248 left, UInt248 right) => new UInt248(left.ToBigInteger() - right.ToBigInteger());
        public static UInt248 operator *(UInt248 left, UInt248 right) => new UInt248(left.ToBigInteger() * right.ToBigInteger());
        public static UInt248 operator /(UInt248 dividend, UInt248 divisor) => new UInt248(dividend.ToBigInteger() / divisor.ToBigInteger());
        public static UInt248 operator >>(UInt248 value, int shift) => new UInt248(value.ToBigInteger() >> shift);
        public static UInt248 operator <<(UInt248 value, int shift) => new UInt248(value.ToBigInteger() << shift);
        public static UInt248 operator |(UInt248 left, UInt248 right) => new UInt248(left.ToBigInteger() | right.ToBigInteger());
        public static UInt248 operator &(UInt248 left, UInt248 right) => new UInt248(left.ToBigInteger() & right.ToBigInteger());
        public static UInt248 operator ^(UInt248 left, UInt248 right) => new UInt248(left.ToBigInteger() ^ right.ToBigInteger());
        public static UInt248 operator ++(UInt248 value) => value + One;
        public static UInt248 operator --(UInt248 value) => value - One;
        public static UInt248 operator ~(UInt248 value)
        {
            // Obtain our bytes
            Span<byte> data = value.ToSpan();

            // Invert all bits.
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = (byte)~data[i];
            }

            // Return the data
            return new UInt248(data);
        }
        #endregion

        #region Casting Operators
        // This Type -> Other Type
        public static explicit operator sbyte(UInt248 value) => (sbyte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator byte(UInt248 value) => (byte)(long)(value.ToBigInteger() & 0xFF);
        public static explicit operator short(UInt248 value) => (short)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator ushort(UInt248 value) => (ushort)(long)(value.ToBigInteger() & 0xFFFF);
        public static explicit operator int(UInt248 value) => (int)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator uint(UInt248 value) => (uint)(long)(value.ToBigInteger() & 0xFFFFFFFF);
        public static explicit operator long(UInt248 value) => (long)(ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator ulong(UInt248 value) => (ulong)(value.ToBigInteger() & 0xFFFFFFFFFFFFFFFF);
        public static explicit operator float(UInt248 value) => (float)value.ToBigInteger();
        public static explicit operator double(UInt248 value) => (double)value.ToBigInteger();
        public static explicit operator decimal(UInt248 value) => (decimal)value.ToBigInteger();
        public static explicit operator BigInteger(UInt248 value) => value.ToBigInteger();

        // Other Type -> This Type
        public static explicit operator UInt248(sbyte value) => new UInt248(value);
        public static implicit operator UInt248(byte value) => new UInt248(value);
        public static explicit operator UInt248(short value) => new UInt248(value);
        public static implicit operator UInt248(ushort value) => new UInt248(value);
        public static explicit operator UInt248(int value) => new UInt248(value);
        public static implicit operator UInt248(uint value) => new UInt248(value);
        public static explicit operator UInt248(long value) => new UInt248(value);
        public static implicit operator UInt248(ulong value) => new UInt248(value);
        public static explicit operator UInt248(float value) => FromFloatingType(value);
        public static explicit operator UInt248(double value) => FromFloatingType(value);
        public static explicit operator UInt248(decimal value) => FromDecimalType(value);
        public static explicit operator UInt248(string value) => TryParse(value, out var result) ? result : FromHexString(value);
        public static explicit operator UInt248(BigInteger value) => new UInt248(value);

        // Sibling Types -> This Type
        public static explicit operator UInt248(Int24 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int40 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int48 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int56 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int72 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int80 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int88 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int96 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int104 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int112 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int120 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int128 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int136 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int144 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int152 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int160 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int168 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int176 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int184 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int192 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int200 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int208 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int216 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int224 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int232 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int240 value) => new UInt248(value.ToBigInteger());
        public static explicit operator UInt248(Int248 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt24 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt40 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt48 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt56 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt72 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt80 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt88 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt96 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt104 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt112 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt120 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt128 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt136 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt144 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt152 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt160 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt168 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt176 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt184 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt192 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt200 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt208 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt216 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt224 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt232 value) => new UInt248(value.ToBigInteger());
        public static implicit operator UInt248(UInt240 value) => new UInt248(value.ToBigInteger());

        public static UInt248 DivRem(UInt248 dividend, UInt248 divisor, out UInt248 remainder)
        {
            BigInteger remainderBigInt;
            var result = new UInt248(BigInteger.DivRem(dividend.ToBigInteger(), divisor.ToBigInteger(), out remainderBigInt));
            remainder = new UInt248(remainderBigInt);
            return result;
        }

        public static UInt248 Pow(UInt248 value, int exponent) => new UInt248(BigInteger.Pow(value.ToBigInteger(), exponent));

        public static double Log(UInt248 value, double baseValue) => BigInteger.Log(value.ToBigInteger(), baseValue);
        #endregion

        #region Functions
        static UInt248 FromFloatingType(double floatingNum)
        {
            if (double.IsPositiveInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert +Infinity into {nameof(UInt248)}");
            }

            if (double.IsNegativeInfinity(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert -Infinity into {nameof(UInt248)}");
            }

            if (double.IsNaN(floatingNum))
            {
                throw new NotFiniteNumberException($"Cannot convert NaN into {nameof(UInt248)}");
            }

            if (floatingNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt248)}");
            }

            var hasFractionalPart = (floatingNum - Math.Round(floatingNum) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt248)}");
            }

            var exponentialNotationStr = floatingNum.ToString("E", CultureInfo.InvariantCulture);
            var bigInt = BigInteger.Parse(exponentialNotationStr, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture);
            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{floatingNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt248)})");
            }

            return new UInt248(bigInt);
        }

        static UInt248 FromDecimalType(decimal decimalNum)
        {
            if (decimalNum < 0)
            {
                throw new OverflowException($"Cannot convert negative number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into {nameof(UInt248)}");
            }

            var bigInt = new BigInteger(decimalNum);
            var hasFractionalPart = (decimalNum - ((decimal)bigInt) != 0);
            if (hasFractionalPart)
            {
                throw new ArithmeticException($"Cannot convert a fractional number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" into a {nameof(UInt248)}");
            }

            if (bigInt > MaxValue.ToBigInteger())
            {
                throw new OverflowException($"Number \"{decimalNum.ToString(CultureInfo.InvariantCulture)}\" is larger than {MaxValue} (the max size of a {nameof(UInt248)})");
            }

            return new UInt248(bigInt);
        }

        public static UInt248 Parse(string value, IFormatProvider provider) => new UInt248(BigInteger.Parse("0" + value, provider));
        public static UInt248 Parse(string value, NumberStyles style) => new UInt248(BigInteger.Parse("0" + value, style, CultureInfo.InvariantCulture));
        public static UInt248 Parse(string value, NumberStyles style, IFormatProvider provider) => new UInt248(BigInteger.Parse("0" + value, style, provider));

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer without commas or decimals. 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Underscores and spaces are ignored. 
        /// </summary>
        public static UInt248 Parse(string numericString)
        {
            return TryParseInternal(numericString, out var result, out var ex) ? result : throw ex;
        }

        /// <summary>
        /// Parses a hex string as bytes. The '0x' prefix is optional.
        /// Examples: "0x12a05f200", "12a05f200", "0xff", "ff", "0xcded53d631ce4a38a1f90d59e5f2f9c023cd28c64aa66488e9462cc4a64a032f"
        /// </summary>
        public static UInt248 ParseHex(string hexString)
        {
            // Obtain our span
            Span<byte> bytes = hexString.HexToSpan();

            // If it's more than the desired size, throw an exception
            if (bytes.Length > SIZE)
            {
                throw new ArgumentException($"Input value for {nameof(UInt248)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
            }

            return new UInt248(bytes, littleEndian: false);
        }

        /// <summary>
        /// Parses a string of a positive numeric value. 
        /// Can be a integer (no decimals). 
        /// Can be a exponential notation, examples: "45e10", "1.23e5", "24E18", "24e+18". 
        /// Commas, underscores, spaces are ignored. 
        /// </summary>
        public static bool TryParse(string numericString, out UInt248 val)
        {
            return TryParseInternal(numericString, out val, out _);
        }

        static bool TryParseInternal(string numericString, out UInt248 val, out Exception ex)
        {
            // Check if the input has a hex prefix
            var trimmed = numericString.Trim().Replace("_", "").Replace(" ", "");
            if (trimmed.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
            {
                ex = new ArgumentException($"Input value contains a hex string prefix. Did you mean to use '{nameof(FromHexString)}'?");
                val = default;
                return false;
            }

            BigInteger bigInt;

            // Check if the input is a number in exponential notation
            var exponentialIndex = trimmed.IndexOfAny(new[] { 'e', 'E' });
            if (exponentialIndex > 0 && exponentialIndex == trimmed.LastIndexOfAny(new[] { 'e', 'E' }))
            {
                if (!BigInteger.TryParse(trimmed, NumberStyles.AllowExponent | NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value is in an invalid exponential notation.");
                    val = default;
                    return false;
                }
            }
            else
            {
                // Check if the value has a decimal
                if (trimmed.Contains('.'))
                {
                    ex = new ArgumentException("Input value should not contain demicals or thousands seperator characters.");
                    val = default;
                    return false;
                }

                // Try to parse the integer
                if (!BigInteger.TryParse(trimmed, NumberStyles.Integer | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out bigInt))
                {
                    ex = new ArgumentException("Input value could not be parsed as an integer.");
                    val = default;
                    return false;
                }
            }

            // Disallow negatives
            if (bigInt.Sign < 0)
            {
                ex = new ArgumentException("Input value should not be negative.");
                val = default;
                return false;
            }

            // Check the the number fits into our byte count
            Span<byte> bytes = bigInt.ToByteArray();
            while (bytes.Length > SIZE && bytes[bytes.Length - 1] == 0)
            {
                bytes = bytes.Slice(0, bytes.Length - 1);
            }

            if (bytes.Length > SIZE)
            {
                ex = new ArgumentException($"Input value for {nameof(UInt248)} is too large. Max size is {SIZE} bytes. Input value was {bytes.Length} bytes.");
                val = default;
                return false;
            }

            ex = null;
            val = new UInt248(bytes, littleEndian: true);
            return true;
        }

        /// <summary>
        /// Alias for <see cref="Parse(string)"/>
        /// </summary>
        public static UInt248 FromString(string numericString)
        {
#pragma warning disable CA1305 // Specify IFormatProvider
            return Parse(numericString);
#pragma warning restore CA1305 // Specify IFormatProvider
        }

        /// <summary>
        /// Alias for <see cref="ParseHex(string)"/>
        /// </summary>
        public static UInt248 FromHexString(string hexString)
        {
            return ParseHex(hexString);
        }

        public int CompareTo(UInt248 other)
        {
            // Compare our type
            if (this == other)
            {
                return 0;
            }
            else if (this < other)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }

        int IComparable.CompareTo(object obj)
        {
            // If our object is null, they are not equal
            if (obj == null)
            {
                return 1;
            }

            // If it's not the correct type, we throw an exception
            if (!(obj is UInt248))
            {
                throw new ArgumentException($"Cannot compare type {obj.GetType().ToString()} to type {nameof(UInt248)}");
            }

            // Compare the underlying object
            return CompareTo((UInt248)obj);
        }

        public bool Equals(UInt248 other)
        {
            // Verify the values equal eachother.
            return this == other;
        }

        public override bool Equals(object obj)
        {
            // If our type is correct, verify it equals. Otherwise return false.
            if (obj is UInt248 parsedInt)
            {
                return Equals(parsedInt);
            }
        
            // Obtain our value as a big integer
            BigInteger bigInt = (BigInteger)obj;

            // It's a big integer, we can cast it to our type and check equality
            return Equals((UInt248)bigInt);
        }

        public override int GetHashCode()
        {
            // Obtain a unique hashcode for our integer.
            return (SIGNED, SIZE, _b0, _b1, _b2, _b3, _b4, _b5, _b6, _b7, _b8, _b9, _b10, _b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21, _b22, _b23, _b24, _b25, _b26, _b27, _b28, _b29, _b30).GetHashCode();
        }

        public BigInteger ToBigInteger()
        {
            // Return our internal big integer
            var buffer = new byte[SIGNED ? SIZE : SIZE + 1];
            int position = 0;
            ToArray(buffer, ref position, ref this, littleEndian: true);
            return new BigInteger(buffer);
        }

        public static void FromByteArray(ReadOnlySpan<byte> buffer, out UInt248 num, bool littleEndian = true)
        {
            num = MemoryMarshal.Read<UInt248>(buffer);
        }

        public static void FromByteArray(Span<byte> buffer, ref int position, ref UInt248 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException($"Failed to parse integer type {nameof(UInt248)} from bytes because there were not enough bytes provided to represent it.");
            }

            // If this is big endian, we'll want to reverse the byte order.
            if (!littleEndian)
            {
                Span<byte> newBuffer = new byte[SIZE];
                buffer.Slice(position, SIZE).CopyTo(newBuffer);
                buffer.Reverse();
                buffer = newBuffer;
            }

            num = MemoryMarshal.Read<UInt248>(buffer.Slice(position));

            position += SIZE;
        }

        public static void ToArray(Span<byte> buffer, ref int position, ref UInt248 num, bool littleEndian = true)
        {
            if (buffer.Length - position < SIZE)
            {
                throw new ArgumentOutOfRangeException();
            }

            MemoryMarshal.Write(buffer.Slice(position, SIZE), ref num);

            // If the user wants a big endian array, we reverse the byte order.
            if (!littleEndian)
            {
                buffer.Slice(position, SIZE).Reverse();
            }

            position += SIZE;
        }

        public Span<byte> ToSpan(bool littleEndian = true)
        {
            int position = 0;
            Span<byte> buffer = new byte[SIZE];
            ToArray(buffer, ref position, ref this, littleEndian);
            return buffer;
        }

        public byte[] ToArray(bool littleEndian = true)
        {
            return ToSpan(littleEndian).ToArray();
        }
        
        public override string ToString()
        {
            // Obtain the value as a string.
            return ToBigInteger().ToString(CultureInfo.InvariantCulture);
        }

        public string ToHexString(bool hexPrefix = true)
        {
            // Obtain a hex string from this integer.
            return ToArray(littleEndian: false).ToHexString(hexPrefix);
        }
        #endregion
    }

    #endregion

}

